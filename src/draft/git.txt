---
layout: note.njk
tags: notes
number : 15
title: Команды git
description: Базовое использование команд git
date: 2021-02-21 23:30:00 +3
main_image: /assets/images/notes/15/main.png
gradient_image: /assets/images/notes/15/gradient.png
themes: linux git
---

## Настройка

Файл конфигурации git считываются в следующем порядке:

1. Локальный для проекта `--local`, по умолчанию.
`project/.git/config`
2. Глобальный для пользователя `--global`
`~/.gitconfig`
3. Общий для всей системы. `--system`
`/etc/gitconfig`
   
Первое, что необходимо сделать — это настроить имя пользователя и email, на нужном уровне конфигурации, эта информация
будет указана в описании коммита.

```shell
# Имя пользователя
git config --global user.name "Alexey Shmelev"
git config --local user.name "user1"

# Email
git config --global user.email "alexsey_89@bk.ru"
git config --local user.email "user1@git.ru"

# Настройка для пользователей windows
# Включить преобразование окончаний строк из CRLF в LF
git config --global core.autocrlf true 

# Список настроек с указанием уровня
git config --list --system
```

## Инициализация и клонирование репозитория

Репозиторий в git необходимо либо инициализировать, либо клонировать с другого места.

~~~shell
# Создание пустого репозитория в текущей директории по факту добавление папки .git
# При этом будет создана ветка по умолчанию (master)
git init 

# Инициализация репозитория без рабочего каталога (создается только каталог .git) используется на сервере:
git init --bare

# Клонирует локальный репозиторий в указанную папку
git clone server test4

# Клонирует репозитоий по протоколу https
git clone https://example.com/gitproject.git

# Клонирует репозиторий по протоколу ssh
git clone ssh://user@server:project.git

# Клонирует репозиторий по протоколу ssh (git поймет что это ssh)
git clone git@github.com:LexusAlex/php-solutions.git

# Клонирует репозиторий по протоколу git
git clone git://user@somehost:port/~user/repository/project.git

# Для создания копии оригинального репозитория
git clone --bare hub.git/ hub2.git # что важно bare репозиторий должен иметь расширение .git
~~~

## Работа с удаленными репозиториями

> При клонировании репозитория, локальный будет привязан автоматически.

```shell
# Добавить удаленный репозиторий с именем origin и main, их может быть несколько
git remote add origin /home/alex/test/server.git
git remote add main git@github.com:LexusAlex/lexusalex.github.io.git

# Удалить привязанный репозиторий
git remote remove origin

# Получить информацию об удаленном репозитории
git remote show origin

# Показать список удаленных репозиториев
git remote -v

# Сопоставить ветки в локальном и в удаленном репозитории
git push --set-upstream origin master

# Отправить данные в удаленный репозиторий
git push origin master

# Забрать данные из удаленного репозитория, из указанной ветки
git pull origin master 

# Получить указанную ветку, но не сливать
git fetch origin master
```

## Рабочий процесс

Когда мы что-то наработали нужно добавить файлы в индекс, для последующего коммита.

```shell
# Добавить в индекс все новые, изменённые, удалённые файлы
git add .

# Добавить в индекс несколько файлов и директории
git add file2 file4 /src /test /myproject # git по историческим причинам не видит пустые директории, для их коммита добавте файлик .gitkeep

# Если не хотим сейчас коммитить, команда поможет вернуть из индекса, но оставить в рабочем каталоге
git restore --staged myFile.txt

# Если хотим полностью откатить фаил к состоянию репозитория, убить в нем все изменения
git restore myFile.txt

# Закоммитим все что есть в индексе
git commit -m "added file"

# А теперь мы хотим закоммитить только определенный файл, не взирая на то, что есть в индексе
git add file2.txt
git commit -m 'added file2' file2.txt
```

Далее процесс опять повторяется

## Отмена и изменение коммитов

Иногда необходимо отменить определенный коммит.

```shell
# В этом случае будет создан обратный коммит выбранному
git revert a3285eab3841eea7ac1727c66abec83e581f5dce
```

А теперь представим ситуацию, что только что был сделан не нужный коммит. Его нужно удалить, для этого нам поможет команда `git reset`

```shell
# Удаляем последний коммит жесткое удаление всего + все сделанные в нем изменения тоже будут удалены
git reset --hard HEAD~

# Если же мы хотим сохранить изменения в рабочей директории, но удалить последний коммит, подойдет команда reset с флагом по дефолту --mixed
git reset HEAD~
```

Часто бывает, что мы хотим что-то добавить или удалить к последнему коммиту.

```shell
# Например забыли добавить file2.txt. Добавляем. Он перешел в индекс
git add file2.txt
git commit --amend
```

git commit -m 'ignore' .gitignore
Состояние файлов:

1. ' ' = unmodified - зафиксирован в репозитории
2.   M = modified - модифицирован
3.   A = added - добавлен
4.   D = deleted - удален
5.   R = renamed - переименован
6.   C = copied - скопирован
7.   U = updated but unmerged - обновлен не не слит

~~~bash
# Добавить в индекс новый, измененный или удаленный фаил
git add file2

# Добавить в индекс несколько файлов и директории
git add file2 file4 /src /test /myproject # git по историческим причинам не видит пустые директории

# Добавить в индекс все файлы в текущей директории и во всех ее поддиреториях
git add .

# Добавить в индекс фаил который есть в файле `.gitignore`, указав флаг `-f`
# После этого работа с файлом ведется обычным образом без указания флага `-f`
git add -f /log/file.log

# Добавить в индекс все файлы кроме созданных
git add -u

# Показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании

git add -p
~~~

### rm

Удаляет файлы и каталоги и добавляет их в индекс

~~~bash
# Рекурсивное удаление файлов и директорий и добавление файлов в индекс
git rm -r /src # что равносильно rm -rf /src, но без добавления в индекс

# Удалить фаил и добавить его в индекс
git rm text.txt

# Удалить любой ценой фаил, даже если он проиндексирован и там есть изменения
git rm -f text.txt # git по умолчанию действует безопасно, если удаляеться измененный фаил, он не даст это сделать

# Удаление файлов по маске
git rm test*

# Если случайно добавили файл в индекс, его нужно убрать из индекса, но сам фаил не удалиться и останется в рабочей директории
git rm --cached file6
~~~

### mv

Переместить или переименовать фаил или каталог.

~~~bash
# Переименовать файл
git mv README.txt README_test.txt

# Переместить фаил
git mv README.txt folder/
~~~

### reset

Сброс к состоянию любого коммита

~~~bash
# Жесткий сброс, полносью перейти в состояние репозитория на указанном коммите с удалением всех незакоммиченный изменений
git reset --hard 6ar5

# Вернуть обратно что сбросили
git reset ORIG_HEAD

# Просто очистить все незакоммиченные изменения из индекса и из рабочей директории
git reset --hard HEAD

# Мягкий сброс, передвинуть на указанный коммит, при этом остаить все незакоммиченные изменения на один коммит назад
git reset --soft @~

# Сброс индекса, по умолчению последний коммит
git reset HEAD

# Сброс индекса, по указанному пути
git reset files/test.php
~~~

### revert

### clean

Удаление неотслежиевамых файлов и директорий

~~~bash
# Удалим все неотслежиеваемые файлы и директории, включая те которые указаны в `gitignore`
git clean -dxf

~~~

### commit

Фиксирует изменения в репозиторий

~~~bash
#  Добавить проиндексированные изменения в репозиторий (закоммитить) с указанием названия коммита
git commit -m "init message"

# Проиндексировать и добавить изменения в репозиторий (закоммитить) при этом новые файлы не будут закоммичены
git commit -a -m "message"

# Отмена последнего коммита, передвигаем текущую ветку назад, но файлы при этом остаються как есть, по факту создается просто новый коммит
git commit --ammend

# Создать новый коммит под замену предыдущему, с изменением сообщения коммита
git commit --ammend -m "comment"

# Просмотреть в редакторе что будет внесено в коммит, то есть какие файлы были изменены
git commit -v
~~~

### branch

Работа с ветками. Ветка это просто указатель на коммит.

~~~bash
# Список веток, с указанием ветки где мы находимся, например
#   master
# * new   # Ссылка на текущую ветку храниться в файле HEAD, при создании коммита git двигает указатель на последний коммит
git branch

# Список веток, и последний коммит в каждой, расширенная информация
#   master 3dd52c7 adds
# * new    3dd52c7 adds
git branch -v

# Создать новую ветку, то есть ссылки на коммит
git branch new

# Переместить ветку на указанный коммит
git branch -f master 61d72

# Переместить ветку на коммит на котором указанная ветка
git branch -f master new2

# Удаление ветки если изменения уже влиты, то есть обьединена, в реальности удаляться только ссылка, коммиты остаются
# Это команда работает только если ветка обьединена со вливаемой
git branch -d new2

# Удалить ветку в любом случае, даже если коммиты не были объединены
git branch -D new2

# Если ветка была удалена по ошибке, восстановить ее можно следующим способом, просто создав новую ветку с тем же именем и указывающее на последний коммит
git branch new2 61d67

~~~

### checkout

Переключение веток и восстановление файлов в рабочем каталоге
Эта команда защищает от переключения при незакоммиченных изменениях, она будет ругатся только если изменения
различатся в обоих ветках, иначе он оставлюет фаил как есть, но выводит заметку

~~~bash
# Перейти в указанную ветку
git checkout new

# Создать новую ветку и сразу же перейти в нее, если были какие-то незакомиченные изменения то они перейдут в нее
git checkout -b new2

# Переключение на другую ветку даже при незакомиченных изменениях, при этом git перезапишет все изменения
git checkout -f master

# Привести все изменения в рабочем каталоге, в состояние последнего коммита в нем, то есть на момент HEAD
# При этом изменения в индексе тоже будут сброшены
git checkout -f HEAD

# Переместить ветку с указанным именем на указанный коммит и перейти в неё
git checkout -B master 61d72

# Перейти на указанный коммит
# Состояние "отделённого HEAD" говорит что в HEAD будет находиться не ветка, а ссылка на конкретный коммит
# Если коммитить далее что ваши коммиты будут висеть в воздухе, рекомендуеться создать новую ветку для этого git checkout -b <имя-новой-ветки>
# Такое перемещение используеться для просмотра истории проекта
git checkout a747

# Восстановить фаил на состояние указанного коммита, при этом не будет происходить переключение веток
git checkout a747 index.php
~~~

### stash

Спрятать изменения в индексе. Важно применять эту команду на одной ветке во избежание конфликтов

~~~bash
# Спрятать изменененения в идексе, используеться для переключения между ветками
git stash

# Вернуть изменения назад
git stash pop

~~~

### merge

Слияние веток

~~~bash
# Слить изменения в текущую ветку из ветки fix(нужно перейти на ветку в которую нужно вливать изменения)
# Слиятние перемоткой Fast-forward, в данном случае, указатель просто сдвигается дальше
git merge fix
~~~

### tag

tag это просто ссылка на коммит, просто метка на коммит

~~~bash
# Создает тег. Тег будет всегда указывать на заданный коммит
git tag v2.0 23th5

# Список тегов
git tag

# Удалить теги
git tag -d v1.1 v2.0

# Создать тег с аннотацией
git tag -a -m "Annotation on tag" 1.1 master
~~~

### log

Просмотр истории коммитов

~~~bash
# Длинный вывод лога, по умолчанию выводит коммиты от HEAD
git log

# Вывод в одну строку
git log --oneline

# Коммиты указанной ветки
git log master

# Показать кол-во последних коммитов
git log -1

# Вывести коммиты в сокращенном формате id коммита(полное или сокращенное) - название
git log --pretty=oneline
git log --pretty=oneline --abbrev-commit
git log --oneline

# Вывод коммитов по формату, ключи указаны в документации
git log --pretty=format:"%h - %an, %ar : %s%d"


~~~

### diff

Сравнение коммитов

~~~bash
# Сравнить коммиты двух веток, разбитым по файлам
# git diff master..branch2 можно и так что тоже самое
git diff master branch2

# Что именно изменилось в branch2 по сравнению с master, то есть сравнение веток
git diff master...branch2

# Сравнить два коммита, разница между файлами двух коммитов
git diff 234fg 5hdf7

# Сравнить изменения в рабочей директории с коммитом который в HEAD
# git diff @
git diff HEAD

# Просмотреть что было изменено и попадет в коммит
git diff --cached

# Изменения в одном файле
git diff index.php

# Изменения текущей директории
git diff .

# Указать путь(директорию) а не ветку для сравнения
git diff -- master

# Сравнить изменения по словам, что именно было изменено
git diff --word-diff
~~~



git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния

git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования







https://ru.stackoverflow.com/questions/431839/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-git-add-add-a-add-u-%D0%B8-add

git remote add local_proj /opt/git/project.git
Придумать пример с одним локальным центральным репозитрием и двумя которые в него сливают

Важно чтобы каждый коммист делал одну вещь, то есть атомарный коммит
В одном коммите только связанные изменения

Стандартные команды Git используемые в различных ситуациях:


работа с текущими изменениями (смотрите также: git help everyday)
   add        Добавление содержимого файла в индекс
   mv         Перемещение или переименование файла, каталога или символьной ссылки
   reset      Сброс текущего состояния HEAD на указанное состояние
   rm         Удаление файлов из рабочего каталога и индекса

просмотр истории и текущего состояния (смотрите также: git help revisions)
   bisect     Выполнить двоичный поиск изменения, которое вносит ошибку
   grep       Вывод строк, соответствующих шаблону
   log        Вывод истории коммитов
   show       Вывод различных типов объектов
   status     Вывод состояния рабочего каталога

выращивание, отметка и настройка вашей общей истории
   branch     Вывод списка веток,  их создание или удаление
   checkout   Переключение веток или восстановление файлов в рабочем каталоге
   commit     Запись изменений в репозиторий
   diff       Вывод разницы между коммитами, коммитом и рабочим каталогом и т.д.
   merge      Объединение одной или нескольких историй разработки вместе
   rebase     Повторно применить коммиты над верхушкой другой ветки
   tag        Создание метки, вывод списка, удаление или проверка метки, подписанной с помощью GPG

совместная работа (смотрите также: git help workflows)
   fetch      Загрузка объектов и ссылок из другого репозитория
   pull       Извлечение изменений и объединение с другим репозиторием или локальной веткой
   push       Обновление внешних ссылок и связанных объектов

----

