---
layout: note.njk
tags: notes
number : 2
title: Тестирование кода в php
description: Как начать тестировать код у себя в проекте
date: 2020-10-18 22:35:00 +3
image: /assets/images/notes/1/main.png
---

Все мы в разной степени начинаем с ручного тестирования кода - это не плохо, 
но возникают ряд проблем.

## Проблемы ручного тестирования кода

1. Отсутствие повторяемости. Одни и те же действия по выявлению ошибок нужно делать многократно (писать print_r() снова и снова), при этом нельзя точно сказать, что было протестировано, а что нет;
2. Ручные тесты "долгие" - это значит что можно часами сидеть и не видеть ошибку;
3. Невнимательность, человеческий фактор, не все было проверенно. Что-то было упущено из вида;
4. Бесконечные правки. В одном месте поправили, сломалось в другом;
5. Приходится постоянно проверять, что результат выполняемой программы соответствует ожидаемому. 
6. При ручных проверках проверить весь функционал просто невозможно.

Справится с этими проблемами помогают автоматические тесты или как еще их называют unit тесты.

Unit тесты — это тестирование одного элемента кода (например, отдельная функция или класс), в изоляции от остальной
части программы.

## Преимущества автоматических(unit) тестов

1. Отладку кода можно сразу вести из тестов, без надобности писать перенаправления, заглушки, exit();, var_dump() и пр.;
2. По тесту можно сразу понять как работает метод, функция, без лишних конструкций. ("Живая документация по коду");
3. Помогают не допускать регрессии готового кода, то есть "новый" код не ломает существующий;
4. Приучают писать маленькие методы и чистые функции, а не пихать всю логику в один метод, который сложно тестировать и поддерживать;
5. Помогают в ходе написания теста понять, как писать менее связанный код;
6. Автоматическая проверка избавляет разработчика от монотонной ручной проверки всего кода приложения;
7. Разработка без страха, править код становится комфортнее, мы уверены что конкретная функция работает, а следовательно уверены за весь код;
8. При правильном написании тестов скорость разработки быстрее чем без них.
9. Запуск тестов - быстрая процедура позволяющая запускать их хоть после каждого изменения в коде.

## Каким должен быть тест

1. Маленьким. Тест должен проверять только одно требование.
2. Легко читаемым. При взгляде на код теста должно быть понятно что происходит.
3. Повторяемым. При каждом запуске тест выдает одинаковый результат.
4. При написании теста, в тест тестируемой функции нужно подставлять результат.
5. Тест должен выполнятся в специальном окружении.
6. Проверять все возможные исходы

## Зависимости кода

Часто результат работы метода зависит от внешних факторов и взамодействует с другими классами и системами.
Например для выполнения своей задачи функции нужен доступ к базе данных или к файлу на диске. 

Чтобы заменить базу данных или файл нужна некая заглушка или фейковый класс, который будет всегда возвращать
предсказуемый результат. Такие классы называют **стабами** от англ. `stub` . При попытке прочитать данные из
бызы данных тесту возвращается готовый массив с данными.

Еще один вид заглушек **моки** от англ. `mock` . Эти классы нужны чтобы, проверить что функция была вызвана с определенными
параметрами. Стабы и моки вместе называют фейками `fakes`.

Для создания `классов-заглушек` нужно создать интерфейс или абстрактный класс и наследовать его от заменяемого класса.

Написание тестов очень сильно зависит от вашей от архитектуры проекта и связанности кода. В проектах с легиси кодом
написание тестов может занять месяцы.

## Пример теста

Функция `sum` возвращает сумму переданного массива:

```php
<?php
function sum (array $numbers) : int {
    if (empty($numbers)) {
        return 0;
    } else {
        return array_sum($numbers);
    }
}
?>
```

Проверим результат двумя тестами `testSumFive` и `testSumZero`:

```php
<?php
function testSumFive (int $sum) : bool {
    if ($sum === 5) {
        return true;
    }
    return false;
}

function testSumZero (int $sum) : bool {
    if ($sum == 0) {
        return true;
    }
    return false;
}

testSumFive(sum([1,3,1])); // true
testSumZero(sum([0])); // true
?>
```

Тесты прошли. Тесты можно писать и так, но запускать их так не удобно. 
Лучше для этого будем использовать специальный фреймворк для написания тестов [phpunit](https://phpunit.de).

## Версии phpunit

Phpunit развивается без обратной совместимости со старыми версиями.
Версия phpunit напрямую зависит от версии php, которая установлена у вас на сервере.

В момент написания этой статьи (ноябрь-декабрь 2020) актуальными и поддерживаемыми являются версии phpunit 8 и 9.

Например если вы используете php 7.0, то будет использоваться версия phpunit 6 или phpunit 5. 
Если ваша версия php 5.3, то phpunit 4. Composer автоматически установит одну из этих версий.

[Поддерживаемые версии](https://phpunit.de/supported-versions.html)

>>Важно учесть, то что если тесты написаны под phpunit 7, в 8 версии они могут
не запустится. При написании тестов придерживайтесь одной мажорной версии, тогда в будущем не будет проблем.

Список текущих версий и их поддержку удобно смотреть на сайте [https://packagist.org/packages/phpunit/phpunit](https://packagist.org/packages/phpunit/phpunit)

## Установка composer

Де-факто стандартным и предпочитаемым способом установки библиотек, является
установка через [composer](https://getcomposer.org/).

Если у вас unix подобная система установим его командой

```shell script
curl -sS https://getcomposer.org/installer | php -- --install-dir=/bin --filename=composer --quiet
```

Для windows есть [инсталятор](https://getcomposer.org/doc/00-intro.md#installation-windows)

## Установка phpunit

Тесты нужно запускать локально в dev окружении разработчика поэтому ставим phpunit в секцию `require-dev`

```shell script
composer require --dev phpunit/phpunit
```

После установки фреймворк добавиться в файл `composer.json`

```json
{
"require-dev": {
    "phpunit/phpunit": "^9.4"
  }
}
```

Теперь станет доступна команда `./vendor/bin/phpunit`, но так запускать не удобно, добавим команду в `composer.json`
в секцию `scripts`

```json
{
"scripts": {
    "test": "phpunit --colors=always"
  }
}
```

Запускаем так `composer test`

> На боевом сервере для того убрать phpunit из автозагрузки
  необходимо выполнить `composer update --no-dev` для запрета установки пакетов из секции `require-dev`.

Я для большего удобства использую `Makefile` для запуска phpunit.

Если в проекте не используется composer, есть также альтернативный способ установки phpunit.
Нужно скачать phar архив и запустить его из указанного места.

~~~shell script
# скачать phar архив
wget -O phpunit https://phar.phpunit.de/phpunit-9.phar
# сделать фаил исполняемым
chmod +x phpunit
# запустить из указанного места
./phpunit
~~~

Если phpunit необходим глобально для всей системы можно переместить файл в директорию со всеми скриптами
`sudo mv phpunit /usr/local/bin/phpunit` теперь команда phpunit будет доступна глобально.

Проверка последней версии phpunit.

```shell script
phpunit --check-version
PHPUnit 9.4.3 by Sebastian Bergmann and contributors.
You are using the latest version of PHPUnit.
```

### Соглашения по написанию тестов

Не существует однозначных правил по написанию тестов, но есть общие рекомендации, которых желательно придерживаться

- Необязательно, но принято исходный код приложения размещать в каталоге `/src`, а тесты в каталоге `/tests`
- Тестовые классы следует наследовать от класса `PHPUnit\Framework\TestCase`
- Тестовый класс следует именовать с постфиксом `*Test` например `/tests/UserTest.php`
- Один класс проекта соответствует одному тестовому классу, но не всегда. Это зависит от связей между классами и архитектуры проекта
- Методы тестирования должны быть публичными и иметь префикс `test*` например `testLogin` или `testAdmin`
- В док блоке теста можно использовать аннотацию `@test`
- Каждый метод тестирования должен запускаться независимо от других, то есть должен быть изолирован.
- Для проверок соответствия реального и ожидаемого результата используются функции утверждения `assert*()` например `assertTrue()`.
- Лучше на начальном этапе ставить меньше проверок, только так можно понять какие проверки нужно добавить в будущем.
- Можно придерживаться общего принципа написания тестов как "Подготовка Действие Утверждение"

### Как запускать

Для запуска тестов необходимо указать директорию или название файлов которые необходимо запустить, например:

```shell script
composer phpunit tests
composer phpunit tests/DummyTest
composer phpunit tests/DummyTest.php
```

Далее будет произведен поиск класса теста, затем будут выполнены тестовые методы этого класса.
Но по-файлово запускать неудобно, поэтому добавим конфигурацию.

### Конфигурация

Создадим фаил конфигурации `phpunit.xml` c настройками по умолчанию.

Проще всего это сделать выполнив команду: 
```shell script
composer phpunit --generate-configuration
```

Будет сгенерирован xml фаил конфигурации:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/9.4/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         cacheResultFile="var/cache/.phpunit.result.cache"
         executionOrder="depends,defects"
         forceCoversAnnotation="true"
         beStrictAboutCoversAnnotation="true"
         beStrictAboutOutputDuringTests="true"
         beStrictAboutTodoAnnotatedTests="true"
         failOnRisky="true"
         failOnWarning="true"
         verbose="true">
    <testsuites>
        <testsuite name="default">
            <directory suffix="Test.php">tests</directory>
        </testsuite>
    </testsuites>
    <coverage cacheDirectory="var/cache/.phpunit.code-coverage" processUncoveredFiles="true">
        <include>
            <directory suffix=".php">src</directory>
        </include>
    </coverage>
</phpunit>
```

Описание параметров можно найти в [документации](https://phpunit.readthedocs.io/en/9.3/configuration.html)

## Пример теста

Теперь перепишем пример теста выше на phpunit 

```php
<?php

declare(strict_types=1);

namespace Tests;

use PHPUnit\Framework\TestCase;

class AbstractTestCase extends TestCase
{

}


class SimpleTest extends AbstractTestCase
{
    public function sum (array $numbers) : int
    {
        if (empty($numbers)) {
            return 0;
        } else {
            return array_sum($numbers);
        }
    }

    public function testSumFive ()
    {
        $this->assertEquals($this->sum([1,3,1]), 5);
    }

    public function testSumZero ()
    {
        $this->assertEquals($this->sum([]), 0);
    }
}
```

### Вывод тестов

При запуске теста для каждого тестового класса будет выведено одно из обозначений:

- `W` - Предупреждение, например `No tests found in class "DummyTest".` если не найдены тестовые методы
- `R` - Тест который не содержит утверждений и будет пропущен `This test did not perform any assertions OK, but incomplete, skipped, or risky tests!`
- `.` - Тест пройден успешно
- `E` - Произошла ошибка во время запуска теста например `Error: Call to undefined function ыыпып()`
- `F` - Тест не пройден, выводится информация почему тест не прошел, например `Failed asserting that false is true.`
- `S` - Тест был отмечен как пропущенный
- `I` - Тест был отмечен как незавершенный

Помимо обозначения в выводе будет и другая информация:

~~~bash
PHPUnit 8.3.4 by Sebastian Bergmann and contributors.

Runtime:       PHP 7.3.4
Configuration: /test-phpunit/phpunit.xml

..                                                                  2 / 2 (100%)

Time: 604 ms, Memory: 4.00 MB

OK (2 tests, 2 assertions)
~~~


### Настройки

У утилиты `./vendor/bin/phpunit` имеется [множество ключей](https://phpunit.readthedocs.io/en/8.3/textui.html), 
но указывать их каждый раз неудобно. Гораздо лучше задать их один раз в конфигурационном файле `phpunit.xml`

### Принципы тестирования


## Полезные Ссылки

https://phpunit.de/supported-versions.html
https://phpunit.de/getting-started/phpunit-8.html
https://www.alexeykopytko.com/2016/phpunit/
https://phpunit.readthedocs.io/ru/latest/index.html
http://volter9.github.io/blog/unit-testing/
https://russianpenguin.ru/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be/
https://gist.github.com/codedokode/a455bde7d0748c0a351a
https://waredom.ru/196#intro

https://medium.com/nuances-of-programming/%D0%B1%D0%B5%D1%80%D0%B5%D0%B6%D0%BB%D0%B8%D0%B2%D0%BE%D0%B5-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BB%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D0%B5%D1%81%D1%82%D1%8B-%D1%85%D1%83%D0%B6%D0%B5-%D1%87%D0%B5%D0%BC-%D0%B2%D1%8B-%D0%B4%D1%83%D0%BC%D0%B0%D0%B5%D1%82%D0%B5-24670e16ab0
https://www.youtube.com/watch?v=zsz8kdi62mE
https://github.com/index0h/php-conventions/tree/feature/20190916-levishchenko-1-basic-php-conventions
https://www.kobzarev.com/programming/phpunit/
