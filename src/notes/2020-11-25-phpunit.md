---
layout: note.njk
tags: notes
number : 2
title: Тестирование кода в php
description: Как начать тестировать код у себя в проекте
date: 2020-10-18 22:35:00 +3
image: /assets/images/notes/1/main.png
---

Все мы в разной степени начинаем с ручного тестирования кода - это не плохо, 
но возникают ряд проблем.

## Проблемы ручного тестирования кода

1. Отсутствие повторяемости. Одни и те же действия по выявлению ошибок нужно делать многократно (писать print_r() снова и снова), при этом нельзя точно сказать, что было протестировано, а что нет;
2. Ручные тесты "долгие" - это значит что можно часами сидеть и не видеть ошибку;
3. Невнимательность, человеческий фактор, не все было проверенно. Что-то было упущено из вида;
4. Бесконечные правки. В одном месте поправили, сломалось в другом;
5. Приходится постоянно проверять, что результат выполняемой программы соответствует ожидаемому. 
6. При ручных проверках проверить весь функционал просто невозможно.

Справится с этими проблемами помогают автоматические тесты или как еще их называют unit тесты.

Unit тесты — это тестирование одного элемента кода (например, отдельная функция или класс), в изоляции от остальной
части программы.

## Преимущества автоматических(unit) тестов

1. Отладку кода можно сразу вести из тестов, без надобности писать перенаправления, заглушки, exit();, var_dump() и пр.;
2. По тесту можно сразу понять как работает метод, функция, без лишних конструкций. ("Живая документация по коду");
3. Помогают не допускать регрессии готового кода, то есть "новый" код не ломает существующий;
4. Приучают писать маленькие методы и чистые функции, а не пихать всю логику в один метод, который сложно тестировать и поддерживать;
5. Помогают в ходе написания теста понять, как писать менее связанный код;
6. Автоматическая проверка избавляет разработчика от монотонной ручной проверки всего кода приложения;
7. Разработка без страха, править код становится комфортнее, мы уверены что конкретная функция работает, а следовательно уверены за весь код;
8. При правильном написании тестов скорость разработки быстрее чем без них.
9. Запуск тестов - быстрая процедура позволяющая запускать их хоть после каждого изменения в коде.

## Каким должен быть тест

1. Маленьким. Тест должен проверять только одно требование.
2. Легко читаемым. При взгляде на код теста должно быть понятно что происходит.
3. Повторяемым. При каждом запуске тест выдает одинаковый результат.
4. При написании теста, в тест тестируемой функции нужно подставлять результат.
5. Тест должен выполнятся в специальном окружении.
6. Проверять все возможные исходы

## Зависимости кода

Часто результат работы метода зависит от внешних факторов и взамодействует с другими классами и системами.
Например для выполнения своей задачи функции нужен доступ к базе данных или к файлу на диске. 

Чтобы заменить базу данных или файл нужна некая заглушка или фейковый класс, который будет всегда возвращать
предсказуемый результат. Такие классы называют **стабами** от англ. `stub` . При попытке прочитать данные из
бызы данных тесту возвращается готовый массив с данными.

Еще один вид заглушек **моки** от англ. `mock` . Эти классы нужны чтобы, проверить что функция была вызвана с определенными
параметрами. Стабы и моки вместе называют фейками `fakes`.

Для создания `классов-заглушек` нужно создать интерфейс или абстрактный класс и наследовать его от заменяемого класса.

Написание тестов очень сильно зависит от вашей от архитектуры проекта и связанности кода. В проектах с легиси кодом
написание тестов может занять месяцы.

## Пример 1

Функция `sum` возвращает сумму переданного массива:

```php
<?php
function sum (array $numbers) : int {
    if (empty($numbers)) {
        return 0;
    } else {
        return array_sum($numbers);
    }
}
?>
```

Проверим результат двумя тестами `testSumFive` и `testSumZero`:

```php
<?php
function testSumFive (int $sum) : bool {
    if ($sum === 5) {
        return true;
    }
    return false;
}

function testSumZero (int $sum) : bool {
    if ($sum == 0) {
        return true;
    }
    return false;
}

testSumFive(sum([1,3,1])); // true
testSumZero(sum([0])); // true
?>
```

Тесты прошли. Тесты можно писать и так, но запускать их так не удобно. 
Лучше для этого будем использовать специальный фреймворк для написания тестов [phpunit](https://phpunit.de).

## Версии phpunit

Phpunit развивается без обратной совместимости со старыми версиями.
Версия phpunit напрямую зависит от версии php, которая установлена у вас на сервере.

В момент написания этой статьи (ноябрь-декабрь 2020) актуальными и поддерживаемыми являются версии phpunit 8 и 9.

Например если вы используете php 7.0, то будет использоваться версия phpunit 6 или phpunit 5. 
Если ваша версия php 5.3, то phpunit 4. Composer автоматически установит одну из этих версий.

[Поддерживаемые версии](https://phpunit.de/supported-versions.html)

>>Важно учесть, то что если тесты написаны под phpunit 7, в 8 версии они могут
не запустится. При написании тестов придерживайтесь одной мажорной версии, тогда в будущем не будет проблем.

Список текущих версий и их поддержку удобно смотреть на сайте [https://packagist.org/packages/phpunit/phpunit](https://packagist.org/packages/phpunit/phpunit)

## Установка composer

Де-факто стандартным и предпочитаемым способом установки библиотек, является
установка через [composer](https://getcomposer.org/).

Если у вас unix подобная система установим его командой

```shell script
curl -sS https://getcomposer.org/installer | php -- --install-dir=/bin --filename=composer --quiet
```

Для windows есть [инсталятор](https://getcomposer.org/doc/00-intro.md#installation-windows)

## Установка phpunit

Тесты нужно запускать локально в dev окружении разработчика поэтому ставим phpunit в секцию `require-dev`

```shell script
composer require --dev phpunit/phpunit
```

После установки фреймворк добавиться в файл `composer.json`

```json
{
"require-dev": {
    "phpunit/phpunit": "^9.4"
  }
}
```

Теперь станет доступна команда `./vendor/bin/phpunit`, но так запускать не удобно, добавим команду в `composer.json`
в секцию `scripts`

```json
{
"scripts": {
    "test": "phpunit --colors=always"
  }
}
```

Запускаем так `composer test`

> На боевом сервере для того убрать phpunit из автозагрузки
  необходимо выполнить `composer update --no-dev` для запрета установки пакетов из секции `require-dev`.

Я для большего удобства использую `Makefile` для запуска phpunit. Об утилите `make` можно узнать из видео [https://www.youtube.com/watch?v=pK9mF5aK05Q](https://www.youtube.com/watch?v=pK9mF5aK05Q) 

Если в проекте не используется composer, есть также альтернативный способ установки phpunit.
Нужно скачать phar архив и запустить его из указанного места.

~~~shell script
# скачать phar архив
wget -O phpunit https://phar.phpunit.de/phpunit-9.phar
# сделать фаил исполняемым
chmod +x phpunit
# запустить из указанного места
./phpunit
~~~

Если phpunit необходим глобально для всей системы можно переместить файл в директорию со всеми скриптами
`sudo mv phpunit /usr/local/bin/phpunit` теперь команда phpunit будет доступна глобально.

Проверка последней версии phpunit.

```shell script
phpunit --check-version
PHPUnit 9.4.3 by Sebastian Bergmann and contributors.
You are using the latest version of PHPUnit.
```

### Соглашения по написанию тестов

Не существует однозначных правил по написанию тестов, но есть общие рекомендации, которых желательно придерживаться

- Необязательно, но принято исходный код приложения размещать в каталоге `/src`, а тесты в каталоге `/tests`
- Тестовые классы следует наследовать от класса `PHPUnit\Framework\TestCase`
- Тестовый класс следует именовать с постфиксом `*Test` например `/tests/UserTest.php`
- Один класс проекта соответствует одному тестовому классу, но не всегда. Это зависит от связей между классами и архитектуры проекта
- Методы тестирования должны быть публичными и иметь префикс `test*` например `testLogin` или `testAdmin`
- В док блоке теста можно использовать аннотацию `@test`
- Каждый метод тестирования должен запускаться независимо от других, то есть должен быть изолирован.
- Для проверок соответствия реального и ожидаемого результата используются функции утверждения `assert*()` например `assertTrue()`.
- Лучше на начальном этапе ставить меньше проверок, только так можно понять какие проверки нужно добавить в будущем.
- Можно придерживаться общего принципа написания тестов как "Подготовка Действие Утверждение"

### Как запускать

Для запуска тестов необходимо указать директорию или название файлов которые необходимо запустить, например:

```shell script
composer phpunit tests
composer phpunit tests/DummyTest
composer phpunit tests/DummyTest.php
```

Далее будет произведен поиск класса теста, затем будут выполнены тестовые методы этого класса.
Но по-файлово запускать неудобно, поэтому добавим конфигурацию.

### Конфигурация

Создадим фаил конфигурации `phpunit.xml` c настройками по умолчанию.

Проще всего это сделать выполнив команду: 
```shell script
composer phpunit --generate-configuration
```

Будет сгенерирован xml фаил конфигурации:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/9.4/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         cacheResultFile="var/cache/.phpunit.result.cache"
         executionOrder="depends,defects"
         forceCoversAnnotation="true"
         beStrictAboutCoversAnnotation="true"
         beStrictAboutOutputDuringTests="true"
         beStrictAboutTodoAnnotatedTests="true"
         failOnRisky="true"
         failOnWarning="true"
         verbose="true">
    <testsuites>
        <testsuite name="default">
            <directory suffix="Test.php">tests</directory>
        </testsuite>
    </testsuites>
    <coverage cacheDirectory="var/cache/.phpunit.code-coverage" processUncoveredFiles="true">
        <include>
            <directory suffix=".php">src</directory>
        </include>
    </coverage>
</phpunit>
```

Описание параметров можно найти в [документации](https://phpunit.readthedocs.io/en/9.3/configuration.html)

## Пример 2

Теперь перепишем пример 1 на phpunit. Для этого создадим класс приложения `/src/Application.php` с единственным методом `sum \`

```php
<?php

declare(strict_types=1);

namespace Application;

class Application
{
    public function sum (array $numbers) : int {
        if (empty($numbers)) {
            return 0;
        } else {
            return array_sum($numbers);
        }
    }
}
```
Для большего удобства создадим абстрактный класс `/tests/AbstractTestCase.php` который наследуем от класса фреймворка `PHPUnit\Framework\TestCase`,
определим метод `setUp`, в нем создадим объект нашего приложения.

> Метод setUp будет запускаться каждый раз при выполнении тестового метода

```php
<?php

declare(strict_types=1);

namespace Tests;

use Application\Application;
use PHPUnit\Framework\TestCase;

abstract class AbstractTestCase extends TestCase
{
    public Application $application;

    protected function setUp(): void
    {
        $this->application = new Application();
        parent::setUp();
    }
}
```

Теперь непосредственного тестовый класс `/tests/ApplicationTest` который наследуем от `AbstractTestCase`,
где будут два тестовых метода с двумя утверждениями

```php
<?php

declare(strict_types=1);

namespace Tests;

class ApplicationTest extends AbstractTestCase
{
    public function testSumFive ()
    {
        $this->assertEquals(5, $this->application->sum([1,3,1]), 'сумма элементов массива не соответствует 5');
    }

    public function testSumZero ()
    {
        $this->assertEquals(0, $this->application->sum([]));
    }
}
```

Запускаем тесты
```shell script
composer test

PHPUnit 9.4.3 by Sebastian Bergmann and contributors.

Runtime:       PHP 7.4.12
Configuration: /template/phpunit.xml

..                                                                  2 / 2 (100%)

Time: 00:00.002, Memory: 6.00 MB

OK (2 tests, 2 assertions)
```

Две точки означают что два наших теста успешно прошли.

Теперь представим что наша функция `sum` работает не правильно.

```shell script
$ composer test
PHPUnit 9.4.3 by Sebastian Bergmann and contributors.

Runtime:       PHP 7.4.12
Configuration: /template/phpunit.xml

.F                                                                  2 / 2 (100%)

Time: 00:00.003, Memory: 6.00 MB

There was 1 failure:

1) Tests\ApplicationTest::testSumFive
сумма элементов массива не соответствует 5
Failed asserting that 25 matches expected 5.

/template/tests/ApplicationTest.php:11

FAILURES!
Tests: 2, Assertions: 2, Failures: 1.
```

Получаем ошибку, где прекрасно видно какой тест упал и что конкретно произошло. 

### Вывод тестов

Теперь разберем вывод тестов, какие обозначения могут быть.

- `W` - В классе не найдены тестовые методы.

```shell script
WW                                                                  2 / 2 (100%)
Warning
No tests found in class "Tests\Application2Test".
WARNINGS!
Tests: 2, Assertions: 0, Warnings: 2.
```

- `.` - Тест пройден успешно

```shell script
..                                                                  2 / 2 (100%)
OK (2 tests, 2 assertions)
```

- `F` - Тест не пройден, выводится информация почему тест не прошел.

```shell script
.F                                                                  2 / 2 (100%)
1) Tests\ApplicationTest::testSumFive
сумма элементов массива не соответствует 5
Failed asserting that 25 matches expected 5.

/template/tests/ApplicationTest.php:11

FAILURES!
Tests: 2, Assertions: 2, Failures: 1.
```

- `R` - Тест не содержит утверждений и будет пропущен.

```shell script
RR                                                                  2 / 2 (100%)
1) Tests\ApplicationTest::testSumZero
This test did not perform any assertions

/template/tests/ApplicationTest.php:14

2) Tests\ApplicationTest::testSumFive
This test did not perform any assertions

/template/tests/ApplicationTest.php:9

OK, but incomplete, skipped, or risky tests!
Tests: 2, Assertions: 0, Risky: 2.
```

- `E` - Произошла синтаксическая ошибка во время запуска теста. При этом подробно указано в каком файле это произошло.

```shell script
EE                                                                  2 / 2 (100%)
1) Tests\ApplicationTest::testSumFive
ParseError: syntax error, unexpected '3232' (T_LNUMBER)

/template/src/Application.php:17
/template/tests/AbstractTestCase.php:16

2) Tests\ApplicationTest::testSumZero
ParseError: syntax error, unexpected '3232' (T_LNUMBER)

/template/src/Application.php:17
/template/tests/AbstractTestCase.php:16

ERRORS!
Tests: 2, Assertions: 0, Errors: 2.
```

- `I` - Не полный или незавершенный тест. Если тест не дописан необходимо вызвать метод `$this->markTestIncomplete('Этот тест ещё не реализован.');`
```shell script
.I                                                                  2 / 2 (100%)

1) Tests\ApplicationTest::testSumFive
Этот тест ещё не реализован.

/template/tests/ApplicationTest.php:13

OK, but incomplete, skipped, or risky tests!
Tests: 2, Assertions: 1, Incomplete: 1.
```

- `S` - Тест был отмечен как пропущенный. Необходимо вызвать метод `$this->markTestSkipped('Этот тест пропущен');`

```shell script
.S                                                                  2 / 2 (100%)

1) Tests\ApplicationTest::testSumFive
Этот тест пропущен

/template/tests/ApplicationTest.php:13

OK, but incomplete, skipped, or risky tests!
Tests: 2, Assertions: 2, Skipped: 1.
```

### Провайдеры данных





### Настройки

У утилиты `./vendor/bin/phpunit` имеется [множество ключей](https://phpunit.readthedocs.io/en/8.3/textui.html), 
но указывать их каждый раз неудобно. Гораздо лучше задать их один раз в конфигурационном файле `phpunit.xml`

### Принципы тестирования


## Полезные Ссылки

https://phpunit.de/supported-versions.html
https://phpunit.de/getting-started/phpunit-8.html
https://www.alexeykopytko.com/2016/phpunit/
https://phpunit.readthedocs.io/ru/latest/index.html
http://volter9.github.io/blog/unit-testing/
https://russianpenguin.ru/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be/
https://gist.github.com/codedokode/a455bde7d0748c0a351a
https://waredom.ru/196#intro

https://medium.com/nuances-of-programming/%D0%B1%D0%B5%D1%80%D0%B5%D0%B6%D0%BB%D0%B8%D0%B2%D0%BE%D0%B5-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BB%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D0%B5%D1%81%D1%82%D1%8B-%D1%85%D1%83%D0%B6%D0%B5-%D1%87%D0%B5%D0%BC-%D0%B2%D1%8B-%D0%B4%D1%83%D0%BC%D0%B0%D0%B5%D1%82%D0%B5-24670e16ab0
https://www.youtube.com/watch?v=zsz8kdi62mE
https://github.com/index0h/php-conventions/tree/feature/20190916-levishchenko-1-basic-php-conventions
https://www.kobzarev.com/programming/phpunit/
