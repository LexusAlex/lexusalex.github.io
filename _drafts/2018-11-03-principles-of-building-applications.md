--- 
layout: post 
title: Принципы построения приложений
permalink: principles-of-building-applications
tags: Построение приложений
comments: true

--- 

https://guides.hexlet.io/check-list-of-engineering-practices/ 
https://ru.hexlet.io/courses/php-functions
https://12factor.net/ru/
https://medium.com/webbdev/solid-4ffc018077da
https://refactoring.guru/ru/refactoring/smells
https://github.com/Hexlet/patterns/tree/master/content паттерны
https://github.com/mokevnin/you-don-t-know-oop ооп
http://optimization.guide/ про оптимизацию

Существуют хорошие практики создания надежных маштабируемых приложений, рассмотрим общие принципы, со стороны кода

Общие принципы
--

-   Приложение обязательно должно быть в [системе контроля версий (VCS)](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8) преимущественно git

    Если не использовать систему контроля версий, то возникают следующие сложности:
    
    -   Как правило код храниться на компьютере разработчика и его сложно передавать другим членам команды
    -   Каждый разрабочик пишет свое решение, в следствии чего тяжело следить и обеспечивать независимую работу программистов
    
-   Требуется наличие автоматизированного средства управления зависимостями, а именно пакетного менеджера , например:

    -   в php [composer](https://getcomposer.org/)
    -   в perl [CPAN](https://www.cpan.org/)
    -   в ruby [rubygems](https://rubygems.org/)
    -   в javaScript [npm](https://www.npmjs.com/)
    -   в python [pip](https://pip.pypa.io/en/stable/)
      
    Как правило зависимости ставятся в отдельную директорию. Важно объявлять зависимости точно и четко в специальном файле (манифесте зависимостей), например:
    
    -   php - composer.json
    -   javaScript - package.json
    -   ruby - Gemfile
   
   Необходимо учитывать, что если для запуска приложения требуется системный инструмент то он должен быть включен в приложение
        
-   Код должен быть общий для всех членов команды, который может быть развернут в приложение (на разных рабочих станциях).
    Развернутым приложением считается любой запущенный экземпляр приложения.
    Нобходимым условием считаеться обеспечить быстрое развертывание (Docker, Vagrant) в требуемой среде:
    
    -   prod1 
    -   prod2 
    -   staging 
    -   testing1 
    -   testing2 
    -   developer1 
    -   developer2 
    -   developer3 
    -   developer4 

    Так же важно, чтобы после развертывания можно было откатится к любой версии проекта в любой среде.
    Изменения в одной среде не должно повлиять на другие среды выполнения
    
-   Использовать единый стиль кода

-  Необходимо строго разделять конфигурацию и код приложения, 
   так как конфигурация приложения для отдельной машины своя и меняеться между развертываниями, а код общий для всех, например:
   
    -   developer1 config - host:localhost, user:local password:local
    -   developer2 config - host:localhost, user:petr password:mypassword
    -   prod config - host:localhost, user:root password:rootpasswd

    Конечно же такие данные не нужно хранить в VCS. 
    Важно определить что являться "кодом" а что "конфигурацией" приложения, исходя из того что меняеться между развертываниями
    Как правильно конфигурацию приложения хранят в отдельны файлах, но так же можно хранить в переменных окружения (env), а это значит:
    
    -   переменные окружения легко изменить
    -   крайне мала вероятность по ошибке сохранения конфигурации в VCS
    
    Еще существует подход группировки по "окружениям", со своим набором конфигураций:
    
    -   dev   
    -   prod   
    -   test   
    
    Наиболее предпочитительным являеться подход с хранением конфигурации в переменных окружения, но здесь многое зависит от проекта

-   Сервис который доступен приложению по сети являться - сторонней службой, к ним относяться например:

    -   Mysql
    -   Memcached
    -   RabbitMQ
    -   Amazon S3
    -   Google Maps
    -   Redis
    
    Нужно предусмотреть возможность быстрого переключения ресурсов, при возможных неисправностях, все это должно происходить
    без изменения в коде
    
-   Этапы работы приложения:
    -   Сборка, происходит клонирование репозитория, загрузка зависимостей
    -   Релиз, происходит объединение текущей конфигурации приложения с результатом сборки, релиз невозможно изменить после его создания
    -   Выполнение, запускает приложение на выполнение
    
    Эти этапы нужно четко и всегда разграничивать   

-   Любые данные, которые требуется сохранить, должны быть сохранены в хранящей состояние сторонней службе, обычно, в базе данных.
    Одно приложение может выступать в роли сторонней службы для другого приложения
    
-   Все процессы приложения могут быть запущены и остановлены в любой момент.
    Приложение должно проектироваться так, чтобы быть устойчивым к сбою аппаратной части 

-   Схожесть окружений.
    Важно использовать одни и те же инструменты 


Принципы Solid
--

Нужно стараться соблюдать эти принципы

Эти принципы относятся к проектированию и архитектуре приложения.

**Single Responsibility Principle**

Принцип единой ответственности. 

Класс должен делать что-то одно. Нельзя позволять делать классу слишком много. Нужно разделять классы по назначению.
Модуль должен отвечать только за одного актора, требуется разделять код

Класс должен решать только одну задачу, например Класс который манипулирует объектом и Класс который манипулирет данными
этого объекта


Вот что по этому поводу говорит Стив Фентон: «Проектируя классы, мы должны стремиться к тому, чтобы объединять родственные компоненты, то есть такие, изменения в которых происходят по одним и тем же причинам. Нам следует стараться разделять компоненты, изменения в которых вызывают различные причины».

**Open-closed Principle**

Принцип открытости/закрытости.

Класс должен быть расширяем без изменения своего содержимого, в тоже время он должен быть закрыт от модификации.
Здесь получается, нужно выделять общие вещи в отдельные интерфейсы

При необходимости расширить класс нужно отнаследоваться от него, и создать новый класс
Нужно использовать расширение возможностей классов, а не их модификация

**Liskov Substitution Principle**

Принцип подстановки Барбары Лисков

Означает, что реализация интерфейса должна быть заменяема в любом месте. То если в интерфейсе в методе мы возвращаем массив,
то и во всех дочерних классах, мы тоже должны возвращать массив и ничего более.



**Interface Segregation Principle**

Принцип разделения интерфейса

Разбивать интерфейсы на независимые части с целью удовлетворения потребностей клиентов

Нужно создавать и разделять интейрфейсы унаследованные от общих интерфейсов

**Dependency Inversion Principle**

Принцип инверсии зависимостей.

Модули зависят от абстракций. Низкоуровневые интерфейсы не зависят от высокоуровневых.



