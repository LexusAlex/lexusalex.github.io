--- 
layout: post 
title: Команды git
permalink: git-commands
tags: git github
comments: true

---

## Список команд

Для удобства разбил команды на группы

- Инициализация и клонирование репозитория
    - [init](#init)
    - [clone](#clone)
- Работа с текущими изменениями
    - [add](#add)
    - [rm](#rm)
    - [mv](#mv)
- Фиксация измений
    - [commit](#commit)
- Ветвление
    - [branch](#branch)
    - [checkout](#checkout)
    - [stash](#stash)
- История
    - [log](#log)
    
      

### init

Создает новый репозиторий

~~~bash
# Создание пустого репозитория в текущей директории:
git init # при этом будет создана ветка по умолчанию (master)

# Создание пустого репозитория в указанной директории:
git init test2

# Инициализация репозитория без рабочего каталога (создается только каталог .git):
git init --bare hub.git

# Инициализация нового репозитория с кратким выводом (ошибки и предупреждения)
git init -q test3
~~~

### clone

Клонирует уже созданный репозиторий

~~~bash
# Клонирует локальный репозиторий в указанную папку
git clone hub.git/ test4

# Вариант клонирования репозитория с указанием полного пути
git clone file:///home/alex/git-test/hub.git/ test5

# Клонирует репозитоий по протоколу https
git clone https://example.com/gitproject.git

# Клонирует репозиторий по протоколу ssh
git clone ssh://user@server:project.git

# Клонирует репозиторий по протоколу ssh (git поймет что это ssh)
git clone git@github.com:LexusAlex/php-solutions.git

# Клонирует репозиторий по протоколу git
git clone git://user@somehost:port/~user/repository/project.git

# Склонируем репозиторий без рабочей папки, например если нужно сделать копию оригинального репозитория
git clone --bare hub.git/ hub2.git # что важно bare репозиторий должен имень расширение .git

# Клонирует репозиторий с указанным в истории кол-вом коммитов, в данном случае в истории будет только последний коммит
git clone --depth 1 https://github.com/LexusAlex/php-solutions.git
~~~

### add

Добавляет файлы в индекс для последующего коммита

Состояние файлов:

1. ' ' = unmodified - зафиксирован в репозитории
2.   M = modified - модифицирован
3.   A = added - добавлен
4.   D = deleted - удален
5.   R = renamed - переименован
6.   C = copied - скопирован
7.   U = updated but unmerged - обновлен не не слит

~~~bash
# Добавить в индекс новый, измененный или удаленный фаил
git add file2

# Добавить в индекс несколько файлов и директории
git add file2 file4 /src /test /myproject # git по историческим причинам не видит пустые директории

# Добавить в индекс все файлы в текущей директории и во всех ее поддиреториях
git add .

# Добавить в индекс фаил который есть в файле `.gitignore`, указав флаг `-f`
# После этого работа с файлом ведется обычным образом без указания флага `-f`
git add -f /log/file.log

# Добавить в индекс все файлы кроме созданных
git add -u

# Показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании

git add -p
~~~

### rm

Удаляет файлы и каталоги и добавляет их в индекс

~~~bash
# Рекурсивное удаление файлов и директорий и добавление файлов в индекс
git rm -r /src # что равносильно rm -rf /src, но без добавления в индекс

# Удалить фаил и добавить его в индекс
git rm text.txt

# Удалить любой ценой фаил, даже если он проиндексирован и там есть изменения
git rm -f text.txt # git по умолчанию действует безопасно, если удаляеться измененный фаил, он не даст это сделать

# Удаление файлов по маске
git rm test*

# Если случайно добавили файл в индекс, его нужно убрать из индекса, но сам фаил не удалиться и останется в рабочей директории
git rm --cached file6
~~~

### mv

Переместить или переименовать фаил или каталог.

~~~bash
# Переименовать файл
git mv README.txt README_test.txt

# Переместить фаил
git mv README.txt folder/
~~~

### commit

Фиксирует изменения в репозиторий

~~~bash
#  Добавить проиндексированные изменения в репозиторий (закоммитить) с указанием названия коммита
git commit -m "init message"

# Проиндексировать и добавить изменения в репозиторий (закоммитить) при этом новые файлы не будут закоммичены
git commit -a -m "message"

~~~

### branch

Работа с ветками. Ветка это просто указатель на коммит.

~~~bash
# Список веток, с указанием ветки где мы находимся, например
#   master
# * new   # Ссылка на текущую ветку храниться в файле HEAD, при создании коммита git двигает указатель на последний коммит
git branch

# Список веток, и последний коммит в каждой, расширенная информация
#   master 3dd52c7 adds
# * new    3dd52c7 adds
git branch -v

# Создать новую ветку, то есть ссылки на коммит
git branch new 

# Переместить ветку на указанный коммит
git branch -f master 61d72

# Переместить ветку на коммит на котором указанная ветка
git branch -f master new2

~~~

### checkout

Переключение веток и восстановление файлов в рабочем каталоге
Эта команда защищает от переключения при незакоммиченных изменениях, она будет ругатся только если изменения
различатся в обоих ветках, иначе он оставлюет фаил как есть, но выводит заметку

~~~bash
# Перейти в указанную ветку
git checkout new

# Создать новую ветку и сразу же перейти в нее, если были какие-то незакомиченные изменения то они перейдут в нее
git checkout -b new2

# Переключение на другую ветку даже при незакомиченных изменениях, при этом git перезапишет все изменения
git checkout -f master

# Привести все изменения в рабочем каталоге, в состояние последнего коммита в нем, то есть на момент HEAD
# При этом изменения в индексе тоже будут сброшены
git checkout -f HEAD

# Переместить ветку с указанным именем на указанный коммит и перейти в неё
git checkout -B master 61d72

# Перейти на указанный коммит
# Состояние "отделённого HEAD" говорит что в HEAD будет находиться не ветка, а ссылка на конкретный коммит
# Если коммитить далее что ваши коммиты будут висеть в воздухе, рекомендуеться создать новую ветку для этого git checkout -b <имя-новой-ветки>
# Такое перемещение используеться для просмотра истории проекта
git checkout a747

# Восстановить фаил на состояние указанного коммита, при этом не будет происходить переключение веток
git checkout a747 index.php
~~~

### stash

Спрятать изменения в индексе. Важно применять эту команду на одной ветке во избежание конфликтов

~~~bash
# Спрятать изменененения в идексе, используеться для переключения между ветками
git stash

# Вернуть изменения назад
git stash pop

~~~

### log

Просмотр истории коммитов

~~~bash
# Длинный вывод лога, по умолчанию вывод коммиты от HEAD
git log

# Вывод в одну строку
git log --oneline 

# Коммиты указанной ветки
git log master

# Показать кол-во коммитов последних коммитов
git log -1


~~~



git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования



Prompt Structure

By default, the general appearance of the prompt is::

(<branch> <upstream branch> <branch tracking>|<local status>)

The symbols are as follows:

    Local Status Symbols
        ✔: repository clean
        ●n: there are n staged files
        ✖n: there are n files with merge conflicts
        ✖-n: there are n staged files waiting for removal
        ✚n: there are n changed but unstaged files
        …n: there are n untracked files
        ⚑n: there are n stash entries
    Upstream branch
        Shows the remote tracking branch
        Disabled by default
        Enable by setting GIT_PROMPT_SHOW_UPSTREAM=1
    Branch Tracking Symbols
        ↑n: ahead of remote by n commits
        ↓n: behind remote by n commits
        ↓m↑n: branches diverged, other by m commits, yours by n commits
        L: local branch, not remotely tracked
    Branch Symbol:
    When the branch name starts with a colon :, it means it's actually a hash, not a branch (although it should be pretty clear, unless you name your branches like hashes :-)



https://github.com/nicothin/web-development/tree/master/git


https://ru.stackoverflow.com/questions/431839/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-git-add-add-a-add-u-%D0%B8-add

git remote add local_proj /opt/git/project.git
Придумать пример с одним локальным центральным репозитрием и двумя которые в него сливают

Важно чтобы каждый коммист делал одну вещь, то есть атомарный коммит
В одном коммите только связанные изменения

Стандартные команды Git используемые в различных ситуациях:


работа с текущими изменениями (смотрите также: git help everyday)
   add        Добавление содержимого файла в индекс
   mv         Перемещение или переименование файла, каталога или символьной ссылки
   reset      Сброс текущего состояния HEAD на указанное состояние
   rm         Удаление файлов из рабочего каталога и индекса

просмотр истории и текущего состояния (смотрите также: git help revisions)
   bisect     Выполнить двоичный поиск изменения, которое вносит ошибку
   grep       Вывод строк, соответствующих шаблону
   log        Вывод истории коммитов
   show       Вывод различных типов объектов
   status     Вывод состояния рабочего каталога

выращивание, отметка и настройка вашей общей истории
   branch     Вывод списка веток,  их создание или удаление
   checkout   Переключение веток или восстановление файлов в рабочем каталоге
   commit     Запись изменений в репозиторий
   diff       Вывод разницы между коммитами, коммитом и рабочим каталогом и т.д.
   merge      Объединение одной или нескольких историй разработки вместе
   rebase     Повторно применить коммиты над верхушкой другой ветки
   tag        Создание метки, вывод списка, удаление или проверка метки, подписанной с помощью GPG

совместная работа (смотрите также: git help workflows)
   fetch      Загрузка объектов и ссылок из другого репозитория
   pull       Извлечение изменений и объединение с другим репозиторием или локальной веткой
   push       Обновление внешних ссылок и связанных объектов

----

