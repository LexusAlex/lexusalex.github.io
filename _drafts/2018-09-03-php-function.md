--- 
layout: post 
title: Php.Про функции
permalink: php-functions
tags: php dev

--- 

Особенности функций в php. Просто что важно знать.

Функция - это особый объект который можно вызвать. 
Как правило функция - это действие.

Рассмотрим пример, мы объявили функцию `additionNumbers()` которая складывает два числа и возвращает результат.
Обратите внимание функцию можно вызвать *до* ее определения, но это плохая практика.
~~~php
echo additionNumbers(5, 8); // 13

/**
 * @param int $a
 * @param int $b
 * @return int
 */
function additionNumbers(int $a, int $b)
{
    return $a + $b;
}

echo additionNumbers(2, 3); // 5
~~~


Функция `additionNumbers()` является **детерминированной** то есть она всегда для одних и тех же входных параметров
возвращает один и тот же результат. Это важно, такие функции проще читать, отлаживать, тестировать. Так же порядок вызова
таких функции не важен.

Напротив недетерминированными являются функции например `rand()` возвращает случайное число, `date('Y')` возвращает текущий год, все эти значения меняются например, 

~~~php
echo rand(); // 808483848
echo rand(); // 940960349

echo date('Y'); // 2018 (скоро год поменяется)
~~~

Перепишем нашу функцию, и выведем полученное число

~~~php
/**
 * @param int $a
 * @param int $b
 * @return int
 */
function additionNumbers(int $a, int $b)
{
    echo $a + $b; // побочный эффект функции
    return $a + $b;
}

additionNumbers(2, 4); // 6
~~~

Теперь функция `additionNumbers()` имеет **побочный эффект**, а именно вывод числа во внешнюю среду выполнения.
То есть если функция обращается к глобальным переменным, или еще хуже меняет их, пишет данные в фаил, выполняет
операцию ввода/вывода, любое внешнее взаимодествие, это функция с побочным эффектом. Необходимо отделять чистый
код функции от побочных эффектов 

## Аргументы

Вычиление аргументов идет слева направо, сначала идут обязательные, а потом необязательные параметры, это убережет от многих проблем в будущем

~~~php
/**
 * Возвращает уникальные номера массива
 * @param array $numbers
 * @return array
 */
function getUniqueNumber(array $numbers = []) : array
{
   return array_unique($numbers, SORT_NUMERIC);
}

print_r(getUniqueNumber([3, 5, 4, 3, 2, 5, 3, 2, 5, 3])); // Array ( [0] => 3 [1] => 5 [2] => 4 [4] => 2 )
~~~

В функции `getUniqueNumber()` в качестве параметра передаем массив, для это используем уточнение типа аргумента.
К настоящему моменту типы которые могут быть заданы в аргументах:

1. Класс/Интерфейс `(SessionHandler $sessionHandler)` / `(Serializable $serializable)`
1. Массив `(array $array)`
1. Функция `(callable $function)`
1. Логический тип `(bool $bool)`
1. Число с плавающей точкой `(float $float)`
1. Число `(int $int)`
1. Строка `(string $string)`
1. Параметр либо массив, либо обьект класса Traversable `(iterable $iter)`
1. Объект `(object $o)`

Псевдонимы для ключевых слов не поддерживаются, так же можно обнулить объявление типа таким образом `(A $a = null)`

Теперь можно передавать в функцию неограниченное число аргументов

~~~php
/**
 * Считает кол-во аргументов переданных в функцию
 * @param mixed ...$arguments
 * @return int
 */
function countArguments (...$arguments) : int
{
    return count($arguments);
}

var_dump(countArguments(1, 2, 9, [], 'str')); // 5
~~~

Как видим стало проще обрабатывать функции с переменным количеством аргументов. 
Также можно при вызове функии распаковать массив в аргументы (предполагается , что функция содержит 5 аргументов):

~~~php
countArguments(...[1, 2, 9, [], 'str']);
~~~

Уточнение типа с многоточием работает точно так же как и с обычными аргументами `(int ...$arguments)`, все элементы массива должны быть числами

В идеале, не допускать в функции больше трех аргументов. Не используйте флаги в качестве параметров функции
## Результат функции

Функция всегда должна возвращать значение, для этого используеться конструкция `return`, при этом если не указать эту конструкцию, то функция вернет `null`
Как и с типами аргументов, можно задать и тип возвращаемых значений 








Функция не должна делать много
Функция может выбрасывать ислючения?
Самое главное это правильная абстракция, принятие ключевых решений нужно откладывать до конца. Слишком рано превращаеться
в слишком поздно

Нужно строить обработку так, чтобы те состояния от которых можно избавиться как можно раньше, мы избавляемся как можно раньше

Кореляция и причинно-следственная связь

Семантическое нарушение, если код рождает тож же самый результат, но не предназначен для этого. Если нет работы 
со стеком то не стоит создавать там это

Отделять побочный эффект от кода функции

Нужно стремится к этому
Побочный эфект
Чистый код
Побочный эфект

Вводить явно выделенные состояния

**Именование**

В php в качестве имени функции можно использовать символы `A-Za-z0-9_`.
При реализации функции мы должны описать действие которое делает функция, для этого используем глагол (напиши, положи и тд.)

~~~php
showDate() // показать дату
removeDate() // удалить дату
print() // вывести
getTableSchema() // вернуть схему таблицы
symbolsCount() // количество символов
~~~

Если функция возвращает логическое значение то используется приставка `is`

~~~php
is_array() // это массив?
is_null() // это null?
isTransactional() // это транзакция?
~~~

Есть внегласные правила в именовании:

~~~php
setProperties() // установить свойства
getId() // вернуть id
hasPath() // проверить путь
hasChild() // проверить на дочерний элемент
canView// кто может просматривать
~~~


----
