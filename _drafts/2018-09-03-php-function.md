--- 
layout: post 
title: Php.Про функции
permalink: php-functions
tags: php dev

--- 

Особенности функций в php. Просто что важно знать.

Функция - это особый объект который можно вызвать. 
Как правило функция - это действие.

Рассмотрим пример, мы объявили функцию `additionNumbers()` которая складывает два числа и возвращает результат.
Обратите внимание функцию можно вызвать *до* ее определения, но это плохая практика.
~~~php
echo additionNumbers(5, 8); // 13

/**
 * @param int $a
 * @param int $b
 * @return int
 */
function additionNumbers(int $a, int $b)
{
    return $a + $b;
}

echo additionNumbers(2, 3); // 5
~~~


Функция `additionNumbers()` является **детерминированной** то есть она всегда для одних и тех же входных параметров
возвращает один и тот же результат. Это важно, такие функции проще читать, отлаживать, тестировать. Так же порядок вызова
таких функции не важен.

Напротив недетерминированными являются функции например `rand()` возвращает случайное число, `date('Y')` возвращает текущий год, все эти значения меняются например, 

~~~php
echo rand(); // 808483848
echo rand(); // 940960349

echo date('Y'); // 2018 (скоро год поменяется)
~~~

Перепишем нашу функцию, и выведем полученное число

~~~php
/**
 * @param int $a
 * @param int $b
 * @return int
 */
function additionNumbers(int $a, int $b)
{
    echo $a + $b; // побочный эффект функции
    return $a + $b;
}

additionNumbers(2, 4); // 6
~~~

Теперь функция `additionNumbers()` имеет **побочный эффект**, а именно вывод числа во внешнюю среду выполнения.
То есть если функция обращается к глобальным переменным, или еще хуже меняет их, пишет данные в фаил, выполняет
операцию ввода/вывода, любое внешнее взаимодествие, это функция с побочным эффектом. Необходимо отделять чистый
код функции от побочных эффектов 

## Аргументы

Вычиление аргументов идет слева направо, сначала идут обязательные, а потом необязательные параметры, это убережет от многих проблем в будущем

~~~php
/**
 * Возвращает уникальные номера массива
 * @param array $numbers
 * @return array
 */
function getUniqueNumber(array $numbers = []) : array
{
   return array_unique($numbers, SORT_NUMERIC);
}

print_r(getUniqueNumber([3, 5, 4, 3, 2, 5, 3, 2, 5, 3])); // Array ( [0] => 3 [1] => 5 [2] => 4 [4] => 2 )
~~~

В функции `getUniqueNumber()` в качестве параметра передаем массив, для это используем уточнение типа аргумента.
К настоящему моменту типы которые могут быть заданы в аргументах:

1. Класс/Интерфейс `(SessionHandler $sessionHandler)` / `(Serializable $serializable)`
1. Массив `(array $array)`
1. Функция `(callable $function)`
1. Логический тип `(bool $bool)`
1. Число с плавающей точкой `(float $float)`
1. Число `(int $int)`
1. Строка `(string $string)`
1. Параметр либо массив, либо обьект класса Traversable `(iterable $iter)`
1. Объект `(object $o)`

Псевдонимы для ключевых слов не поддерживаются, так же можно обнулить объявление типа таким образом `(A $a = null)`

Теперь можно передавать в функцию неограниченное число аргументов

Splat оператор
~~~php
/**
 * Считает кол-во аргументов переданных в функцию
 * @param mixed ...$arguments
 * @return int
 */
function countArguments (...$arguments) : int
{
    return count($arguments);
}

var_dump(countArguments(1, 2, 9, [], 'str')); // 5
~~~

Как видим стало проще обрабатывать функции с переменным количеством аргументов. 
Также можно при вызове функии распаковать массив в аргументы (предполагается , что функция содержит 5 аргументов):

~~~php
countArguments(...[1, 2, 9, [], 'str']);
~~~

Уточнение типа с многоточием работает точно так же как и с обычными аргументами `(int ...$arguments)`, все элементы массива должны быть числами

В идеале, не допускать в функции больше трех аргументов. Не используйте флаги в качестве параметров функции

## Результат функции

Функция всегда должна возвращать значение, для этого используеться конструкция `return`, при этом если не указать эту конструкцию, то функция вернет `null`
Как и с типами аргументов, можно задать и тип возвращаемых значений (аналогично аргументам)

## Анонимные функции

Это функция без имени






Чистые функции обладают рядом ключевых достоинств:

    Их крайне просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
    Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
    Их легко комбинировать получая новое поведение без необходимости переписывать программу (подробнее далее по курсу).

являеться ли число простым

function isPrime(int $num)
{
    if ($num < 2) {
        return false;
    }

    for ($i = 2; $i < $n um / 2; $i++) {
        if ($num % $i == 0) {
            return false;
        }
    }

    return true;
}

function sayPrimeOrNot($num)
{
    $text = isPrime($num) ? 'yes' : 'no';
    print_r($text);
}


<?php

namespace App\Math;

// BEGIN (write your solution here)
function average(...$arg)
{
    if(empty($arg)) {
        return null;
    }

    return (array_sum($arg) / count($arg));
}
// END
команда

Всегда связана с выплнением побочных эффектов

запрос

Не меняет состояние системы



array_map отображение
array_filter фильтрация элементов массива
array_reduce  агрегация

Нужно выделать опрации отображения, фильтрации и агрегации в отдельные сущности

Функция не должна делать много
Функция может выбрасывать ислючения?
Самое главное это правильная абстракция, принятие ключевых решений нужно откладывать до конца. Слишком рано превращаеться
в слишком поздно

Нужно строить обработку так, чтобы те состояния от которых можно избавиться как можно раньше, мы избавляемся как можно раньше

Кореляция и причинно-следственная связь

Семантическое нарушение, если код рождает тож же самый результат, но не предназначен для этого. Если нет работы 
со стеком то не стоит создавать там это

Отделять побочный эффект от кода функции

Нужно стремится к этому
Побочный эфект
Чистый код
Побочный эфект

Вводить явно выделенные состояния

**Именование**

В php в качестве имени функции можно использовать символы `A-Za-z0-9_`.
При реализации функции мы должны описать действие которое делает функция, для этого используем глагол (напиши, положи и тд.)

~~~php
showDate() // показать дату
removeDate() // удалить дату
print() // вывести
getTableSchema() // вернуть схему таблицы
symbolsCount() // количество символов
~~~

Если функция возвращает логическое значение то используется приставка `is`

~~~php
is_array() // это массив?
is_null() // это null?
isTransactional() // это транзакция?
~~~

Есть внегласные правила в именовании:

~~~php
setProperties() // установить свойства
getId() // вернуть id
hasPath() // проверить путь
hasChild() // проверить на дочерний элемент
canView// кто может просматривать
~~~

давай-те функциям понятные названия



Вот, теперь мы подобрались к сути. Вы исходите из ошибочного предположения что обучение на хекслете это только последовательность уроков. Но на самом деле, главная фишка проекта это менторская поддержка (то чем я сейчас и занимаюсь). Вспомните школу или институт. Если бы можно было учиться только за счет грамотно простроенного контента, то преподаватели стали бы просто не нужны. Но мир так сложен, что невозможно научить без поддержки со стороны живого человека. Например для того чтобы вы смогли написать хорошо даже примитивную программу (скажем строк на 10), мне нужно вас обучить такому количеству вещей, что вы бы сказали "пойду найду другую школу, тут какие-то теоретики и за месяц я даже не дошел до того чтобы начать писать код". Поэтому любое обучение всегда идет с пропусками, которые нагоняются в процессе и не последнюю роль играет в этом ментор (и в целом та база знаний которая появляется в вопросах ответах). И даже при такой структуре, нет никакой физической возможности обучить вас всем хорошим практикам. После любого института человек на производстве доучивается и переучивается месяцами, а то и годами.

Так что по сути мой ответ был как раз тем самым живым обучением, которым вы бы могли воспользоваться и, например, задать уточняющие вопросы или попросить пояснить. Примерно такую реакцию ожидает преподаватель от заинтересованных учеников. В том как это работает вы можете легко убедиться почитав другие топики, где разворачиваются большие и интересные дискуссии.

p.s. я не дружу с запятыми, так что не серчайте)


----
