---
layout: post
title:  Sicp часть 1. Элементы программирования
date:   2018-01-07
author: Алексей Шмелев
categories: sicp
tags:	
comments: true
cover:  "/assets/hello/hello.jpg"
---

# Sicp

Читаю книгу СИКП и решаю задачи, основные мысли по поводу этого.

### Элементы програмирования

Диалект лиспа Scheme имеет префиксную натацию, что означает, что оператор ставится слева от выражения
Преимущества префиксной нотации в следующем:
- Не возникает неоднозначности, оператор всегда находится слева, комбинация ограничена скобками `(+ 23 45 2)`
- Элементы можно вкладывать друг в друга, в свою очередь элементы могут сами комбинациями, при этом не существует ограничение на вложенность элементов `(+ (* 2 2) (- 8 1))`

Для вычисления комбинаций требутеся вычислить все подвыражения и применить процедуру левого оператора.
Правило вычисления рекурсивно по своей природе, вычисления идут из глубины выражения

### Определение процедур

```
 (define (square x) (* x x))
```
Эта процедура возводит число в квадрат

(define (имя параметры) (тело))

Сумма квадратов
```
(define (sum-of-squares x y)
(+ (square x)(square y)))

```

В этом случае мы используем определеленную выше процедуру square для вычисления тела функции суммы квадратов.

### Два порядка вычиления процедур

- Апликативный

    В данном случает вычисляются оператор и операнды, затем аргументы.При этом будут вычислены все элементарные. Например
    
    ```
    (sum-of-squares (+ a 1) (* a 2))
    (sum-of-squares (+ 5 1) (* 5 2))
    (+ (square 6) (square 10))
    (+ (* 6 6) (* 10 10))
    (+ 36 100)
    136
    
    ```
- Нормальный

    Здесь вычисление будет идти то тех пор пока не получим элементарные выражения    

    ```
    (sum-of-squares (+ 5 1) (* 5 2))
    (+ (square (+ 5 1) ) (square (* 5 2) ))
    (+ (* (+ 5 1) (+ 5 1) ) (* (* 5 2) (* 5 2) ))
    (+ (* 6 6) (* 10 10))
    (+ 36 100)
    136
    
    ```
Данные процессы дают один и тот же результат, в лиспе используется апликативный порядок вычислений

### Предикаты

cond, if - разбор случаев
````
    (define (abs x)
    	(cond ((> x 0) x)
    	      ((= x 0) 0)
              ((< x 0) (- x))))
    
    (define (abs x)
    	(cond ((< x 0) (- x))
        (else x)))
        
    (define (abs x)
     	(if (< x 0)
     	    (- x)
     	    x))    
````
Ветви. первое выражение в ветви это предикат (возвращаютс истину или ложь #f или #t) . if используется когда есть два возможных исхода.
Отличие cond от if в том что, в cond можно записать несколько выражений, в if только одно.
Для составления составных предикатов используются логические значения and,or,not.

````
(and (> x 5) (< x 10))
(or (> x 5) (< x 10))
(not (> x 5))

````

### Упражение 1.2
Перевести выражение в префикную форму

```
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)) )

- 37
 ----
 150

```


