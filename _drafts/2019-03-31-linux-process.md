--- 
layout: post 
title: Linux.Процессы и потоки
permalink: linux-process
tags: linux

--- 
### Программа и библиотека

Для понимания как устроен процесс в операционной системе Linux, нужно дать определение понятиям:

- Программа - это набор инструкций написанные на языке высокого уровня или на машинном языке, понятном ценральному
процессору. Программа должна быть переведена на язык исполнения, для этого используются трансляторы 
[компилятор](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80) и 
[интерпретатор](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80)

- [Библиотека](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))



### Понятие процесса

Программы изолирутся друг от друга в "Виртуальной среде", которая обеспечивает процесс их выполнения.

Процесс - это среда выполнения программ или программа которая находится в процессе выполнения, то есть
такой контейнер для всех ресурсов необходимых для многозадачного выполнения программ как
последовательны так и параллельных, можно еще сказать что это черный ящик.

Одну и ту же программу можно выполнить в нескольких процессах.

USER
	

Имя владельца процесса

PID
	

Идентификатор процесса

%CPU
	

Доля времени центрального процессора (в процентах), выделенная

 
	

данному процессу

%МЕМ
	

Часть реальной памяти (в процентах), используемая данным процессом

VSZ
	

Виртуальный размер процесса в килобайтах

RSS
	

Размер резидентного набора (количество страниц памяти размером

 
	

1 Кб)

тт
	

Идентификатор управляющего терминала

STAT
	

Текущий статус процесса:

 
	

R — выполняется

 
	

D — ожидает записи на диск

 
	

I — неактивен (< 20 с)

 
	

S — неактивен (> 20 с)

 
	

Т — приостановлен

 
	

Z — зомби

 
	

Дополнительные флаги:

 
	

> — процесс имеет повышенный приоритет

 
	

N — процесс имеет пониженный приоритет

 
	

< — процесс превысил программный лимит на использование памяти

 
	

А — процесс запросил замену произвольной страницы

 
	

S — процесс запросил замену страницы по принципу FIFO

 
	

V — процесс приостановлен на время выполнения вызова vfork

 
	

Е — процесс пытается выполнить вызов exit

 
	

L — некоторые страницы блокированы в оперативной памяти

 
	

X — процесс находится в состоянии трассировки или отладки

 
	

S — процесс является лидером сеанса (владельцем управляющего

 
	

терминала)

 
	

w — процесс выгружен на диск

 
	

+ — процесс находится в интерактивном режиме своего

 
	

управляющего терминала

STARTED
	

Время запуска процесса

TIME
	

Время центрального процессора, затребованное процессом

COMMAND
	

Имя и аргументы команды1

### Внутреннее устройство процесса

![process](/assets/images/2018-08-12-linux-process/process1.png "process")


Программа это контейнер

Процесс - это среда выполнения
Когда программа выполняет операции ввода вывода

Многозадачные ОС

Процесс - это вирт среда, где программа думает что она видит и есть компьютер, хотя это только его часть

1 программа зависит от n библиотек, и библиотеки зависят от библиотек

виртуальная среда 0 - 2(32) 4 гб - максимально адресуемое адресное пространство на 32 битах
В реальности выделяется столько столько нужно
4 гб деляться на 
2гб (Kernel, для обслуживания ядра)  какие файлы открыты
2гб (Process)
 
Исполняемый файл процесса зависит от библиотек 
 
 
Основа процесса - это виртульаная память
 
Что в процесс попадает
1. Text(Code)(r-x) -  программный код, то есть те инструкции которые были взяты
из исполняемый файлов для выполнения, можно ли его читать или выполнять

2. Data (RWDATA)(rw) (RODATA) (r--) - данные программ, нельзя выполнять но можно писать

3. Stack для огранизации процедурных вычислений (A-B-C-A) Очередность выполнения программ, 

Динамические сегменты

4. Heap -  динамичекие данные операционной системы для чтения данных
порядок освобожения не определен, до тех пор пока пямять в 2гб для этого процесса не закончиться

Ресурс процесса закончиваеться когда заканчивается память процесса

### Как формируеться содержимое процесса

При запуске программы формируется процесс, и его содержание заполняються сегменты секции процесса.
Библиотке может попасть в сегменты процесса если явно связана с исполняемым файлом 
или при неявной загрузки в момент выполнения при выполнении программы


Когда мы запускам программы в консоли, тогда запускаються соответствующие программы из 
/bin (основные) или /sbin (прикладные) , они используют раздляемые библиотки


Программа как правило состоит из исполняемых файлов (Executable files) и связанных с нею библиотек (Libraries)

Программы находятся в каталогах:

~~~bash
/bin
/sbin
/usr/bin
/usr/sbin
/usr/local/bin
/usr/local/sbin
~~~

Библиотеки в каталогах:

~~~bash
/lib
/usr/lib
/usr/local/lib
~~~

Между программой и библиотекой существует зависимость, посмотреть от каких библиотек зависит программа
можно командой `ldd`

~~~bash
ldd /bin/cat
	linux-vdso.so.1 =>  (0x00007ffd35a6a000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f688883c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f6888c06000)
~~~
Самая важная библиотка это библиотка языка C

libc.so.6

lib - библиотека
c - название
.so - Shared Object Name разделяемый интерфейс
6 - версия интерфейса

лежат они обчно в /lib 

Где отображаеться имя библиотеки (Shared Object Name), фаил библиотеки и адрес в памяти процесса куда она будет загружена
Исполняемые файлы программы зависят от библиотек, библиотеки в свою очередь могут зависеть от других библиотек, например

~~~bash
ldd /lib/x86_64-linux-gnu/libc.so.6
	/lib64/ld-linux-x86-64.so.2 (0x00007fae36b4c000)
	linux-vdso.so.1 =>  (0x00007fff51bcc000)
~~~

### Зависимости

Узнать от чего зависит программа `ldd /bin/ls` сплющенное дерево зависимостей
Самая важная библиотка это библиотка языка C libc.so.6
Воображаемая библиотка linux-gate.so.1 как шлюз

Библиотка - это раздяляемый обьект - его нужно явно загрузить
Программа - это исполняемый обьект - нужно запустить 

Можно проверть от чего зависит программа или библиотки командой `ldd`

libwrap.so.0.7.6 , где 
0 - номер версии интерфейса то что реализуемо 
7 - номер версии реализации ()
6 - исправлении ошибок - говорит о том что 6 раз исправлялась 7-я реализация библиотки


### Файлы процесса

`top` - верхние процессы, потребление ресурсов

ps ax - процессы текущего сеанса
ps ax | wc -l - посчитать процессы
ps u - для пользователя
ps j - система управления заданиями

ps axo pid,user - кастомизируем вывод как нужно
ps ufx - строим дерево

strace ps


ps axo pid,ppid,sid,pgid,tpgid,comm,nice,pri
Каждый из процессов имеет свой обьем виртуальной памяти

Запросы команды ps можно формировать равно так как нам в реальности нужно
Всю информацию о процессах эти команды черпают их каталога /proc
можно зайти туда и посмотреть информацию
Там можно посмотреть карту сегментов процесса, библиотки, программы, код программы куча, стек, окрытые файлы
В превдосистеме proc можно увидеть всю поднаготную процесса, просто нужно знать что искать

maps карта

### Атрибуты процесса

Это его свойства, механизм управления заданиями

свойства процесса

WD - Рабочий каталог - точка отсчета относительных путевых имен
UMASK - Реверсивная маска доступа к процессу прав доступа

Enviroment - Переменные окружения процесса (Var1, Var2, Var3, Var4)

Атрибуты механизма упралевения заданиями
PID - Идентификатор процесса - число, уникальный идентификатор, в процессе может выполнтся часть программы а может и несколько программ
PPID - Идентификатор родительсского процесса
SID - Идентификатор сеанса, все процессы одного пользователя на одном терминале,
TTY - Идентификатор терминала, управляющий процессом, через какой терминал можно им управлять
PGID - Идентификатор группы процесса,
TPGID - Терминальная группа процессов (foreground group) - особенная группа среди всех групп


// Читать подробнее о приорететах процесса
NICE - Относительный приоретет ((Low)20  0 -19 (High))
high -19
0   приоретет по умолчанию
low  20

PRI - Абсолютный приоретет - Чем больше тем лучше

Режим контроля доступа, от чего лица работает процесс
RUID - Real UID Настоящий идентификатор пользователя именно этот пользователь запустил эту программу в этом процессе
EUID - Effective UID Действующий идентификатор, то от кого программа работает, кто бы ее не запустил
RGID - Real GID Группа
EGID - Effective GID

В большинстве случаем они равны (SUID), но не в общем случае

  PID  RUID  EUID  RGID  EGID USER
 1417     0     0     0     0 root
 1880     0     0     0     0 root
 4726  1000  1000  1000  1000 alex
 5747  1000  1000  1000  1000 alex
12766  1000  1000  1000  1000 alex
15866  1000  1000  1000  1000 alex

Программу может запускать один пользовать, а выполнятсяч она может от другого пользователя

Запросы команды ps можно формировать так как нам в реальности нужно

Программа запущенная в операционной системе будет всегда иметь процесс

Процессор переключается между процессами, предоставляя каждому процессу долю процессорного времени - это называется многозадачным режимом работы.
По сути процесс - это действия выполненные при чтении программы, у него есть входные, выходные данные и состояние. 
Программа может быть сохранена в виде текста, процесс может только выполняться. 
Есть возможность запустить два процесса от одной программы.

### Порождение нового процессов

PID1
Выполнение системного вызова fork()
COPY Клонирование процесса PID1, теперь процессы стали разными но содержимое одинаковое PID2
PID1 parent PID2 child

Для параллельного выполнения программ, приведен пример с веб сервером
 

### Запуск новой программы

PID1
exec() - контейнер просесса остался, а содержимое заместилось загразкой новой программы
Процесс остался прежним

### Запуск в новом процессе новой программы

PID1
Выполнение системного вызова fork() - раздвоиться
COPY Клонирование процесса PID1 в PID2
Выполнение системного вызова exec() - запуститься новой программы путем замещения содержимого процесса PID1
LOAD Загрузка новой программы


### Завершение работы процесса

PID1 parent
PID2 child
чтобы завершить выполнение прорамма выполняет системный вызов exit()
так как процессы не знают ничего о других процессах они должны вернуть сигнал SIGCHLD (код возврата) этот механизм ассинхронный
Родитель обязан с помощью wait() забрать код возврата из ядра
Zombie - процесс еще существует, но по факту его нет, уничтожена только после принятия родителей кода возврата


Процессы порождаются другими процессами и деваются в никуда

Апач к примеру запустился несколько раз первый процесс из них является диспетчером

### Механизм сигналов

Сигналы оповещение процессов о наступлении событий

kill() - завершение процесса посылка процессу сигрнала о завешении другого процесса

Завешение происходит в добровольном порядке

Сигналы
SIGHUP        1       Term    Hangup detected on controlling terminal or death of controlling process
SIGINT        2       Term    Interrupt from keyboard ctr c tty
SIGQUIT       3       Core    Quit from keyboard ctl \ tty
SIGILL        4       Core    Illegal Instruction
SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal завершить процесс
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                             readers
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal - аналог 2
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
SIGCHLD   20,17,18    Ign     Child stopped or terminated
SIGCONT   19,18,25    Cont    Continue if stopped
SIGSTOP   17,19,23    Stop    Stop process
SIGTSTP   18,20,24    Stop    Stop typed at terminal ctl Z приостановка
SIGTTIN   21,21,26    Stop    Terminal input for background process
SIGTTOU   22,22,27    Stop    Terminal output for background process

Можно послать сигнал на завершение процессу из одного сеанса в другой сеанс

ctrl z приостановить программу
ps jf
jobs -l задание

fg %1 - продолжить выполнение задания с того места где остановились

В сеансе сущестуют группы, но только одна группа -это группа переднего фона (там есть лидер процесс), все остальные заднего фона


## Создание  процесса

Новый процесс всегда создается за счет уже существующего процесса. Чтобы создать "процесс-потомок" родительский процесс 
выполняет системный вызов `fork()`, "процесс потомок" является копией родительского процесса. 
Далее новый процесс начинает жить "своей жизнью", например с помощью выполнения системного вызова `exec()`, загружает в пространство процесса
новую программу, при этом родитель и потомок обладают своим собственным адресным пространством.

## Завершение процесса

Процесс может быть завершен если он завершил свою работу либо при возникновении ошибок. Так же можно принудительно
завершить процесс командой `kill {pid процесса}`

## Состояния процесса

Здесь процесс может выполняться, ждать или быть заблокированным. Важно решить сколько процессорного времени какой процесс будет выполняться
за это отвечает **планировщик**. 

Планировщик - работает на самом низком уровне операционной системы, он занимается обработкой прерываний.
Планировщик использует **таблицу процессов**, в ней находятся все сведенья о состоянии процесса.

Некоторые характеристики процесса:
    
  1. Регистры
  1. Счётчик команд
  1. Слово состояния программы
  1. Указатель стека
  1. Состояние процесса
  1. Приоритет
  1. Параметры планирования
  1. Идентификатор процесса
  1. Родительский процесс
  1. Группа процесса
  1. Сигналы
  1. Время начала процесса
  1. Использованное процессорное время
  1. Процессорное время дочернего процесса
  1. Время следующего аварийного сигнала
  1. Указатель на текстовый сегмент
  1. Указатель на сегмент данных
  1. Указатель на сегмент стека
  1. Корневой каталог
  1. Рабочий каталог
  1. Дескриптор файла
  1. Идентификатор пользователя
  1. Идентификатор группы

Процесс может быть прерван множество раз, но после прерывания процесс возвращается к тому же состоянию в котором он был,
до прерывания.

## Потоки

У каждого процесса есть адресное пространство, при необходимости параллельных вычислений, выделяют **потоки**, которые
используют общую память.

Для примера можем взять процесс веб-сервера, он имеет поток диспетчера, несколько рабочих потоков. Где поток диспетчер - это
бесконечный цикл, для получения рабочего запроса, далее запрос передается рабочему потоку.


----

$ command -x 1 [-x 2 args] {-x n | --long-options i } args ...

cnt + j (^j) или enter
