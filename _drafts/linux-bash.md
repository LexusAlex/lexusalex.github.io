---
layout: post
title: Программировние на bash
permalink: php-standards-recommendations 
tags: psr php
comments: true
subtitle: Какие существуют стандарты кодирования в php
summary: Какие существуют стандарты кодирования в php
is_navigate: true
cover_url: "/assets/images/articles/php.png"
---

#### Структура командной строки

`alex@test:~$ command -x 1 [-x 2 args] {-x n | --long-options i } args ...`

`alex@test:/tmp/.X11-unix$` - эта часть это просто справочная информация где :
- `alex` имя учетной записи пользователя
- `@` разделитель
- `test` имя компьютера
- `:` разделитель
- `/tmp/.X11-unix` директория где мы находимся и где выполнятеся команда
- `$` приглашение к выполнению команды от обычного пользователя, `#` от суперпользователя

Пример.

```bash
root@debian10:/tmp/.X11-unix#
```

Команда представляет из себя все что идет после приглашения.
В простейшем случае команда это одно слово, но по факту это путь до исполняемого файла.
Чтобы выполнить команду нужно запустить ее выполнение нажав enter

```bash
ls
pwd
cd
ps
find
date
touch
man
mkdir
```
После запуска будет выведен или не веведен результат выполнения.
Значения по умолчанию - это хорошо, но хочется большего. 
Например указание агрументов команды. Их может быть несколько

```bash
ls /tmp/
cd /tmp/
touch /tmp/testfile
mkdir mytestfolder
rm test1 test2 test3 test4
cat file1 file2
stat file
```

Существует так же возможность более точно сказать интерпретатору что мы хотим, для этого
существуют ключи или модификаторы. Обычно они указываются между командой и агрументами команды

```bash
ls -a /tmp/
ls -a -l /tmp/
tail -f /var/log/messages
```

У ключей тоже могут быть аргументы, они должны идти сразу после ключа

```bash
ls -T 3 -w 1 /
```

Это были короткие ключи, но так же бывает и длинные с агрументами или без:

```bash
ls --sort=size --dereference-command-line /
find . -maxdepth 1 -size 0
```

### Подстановки

#### Подстановка имен файлов

- `*` метасимвол означающий сколько угодно и каких угодно символов
- `?` любой символ, но один
- `~` домашний каталог
- `\` специальный символ для отмены значений других символов
- `[x-z]` диапазон
- `[abcd]` пересичление, один конкретный символ
`ls ja*`

`du -sh ~/*`

#### Экранирование

- `\m` одиночное
-  `'mmmmmm'` множественное условное
-  `"mmmmmm"` множественное сильное экранирует все

** Чтобы видеть все подстановки нужно включить трассировку set -x включить трассировку всего set +x выкл трассировку**


### Подстановка вывода команд
`comand`
$(comand)

rm `find . -maxdepth 1 -size 0`





11 минута
Программирование на bash

https://habr.com/ru/company/ruvds/blog/325522/
$ command -x 1 [-x 2 args] {-x n | --long-options i } args ...

~ - домашний каталог
* - любой символ сколько угодно
? - любой но один символ
[x-y] - диапазон
[abc]

m 1 m 2 m...m n ’ - множественное экранирование
”m 1 m 2 m...m n ” - множественное экранирование
\m одиночное

ls -l mu* - любое кол-во символов
ls -la mu?????? - 6 любых символов
ls -la ???????? - 8 любых символов
[mr]*
ls -ld *-*
ls -ld /etc/*[0-9]*
find . -maxdepth 1 -size 0
wc -l

Подстановка вывода команд ` `  $()
rm `find . -maxdepth 1 -size 0`
rm $(find . -maxdepth 1 -size 0) 
cmd1 $(cmd2 $(cmd3))
cmd1 $(cmd2) $(cmd3)

touch "name test"

find /usr -size +35k
find /usr -size +$[5 * 1024]k -ls
find /usr -size +$[5 * 1024]k | wc -l - арифметическая подстановка
echo $[2**10]

Подстановка параметров 
echo $LANG 
echo ${LANG}test 

set -x включить трассировку всего 
set +x выкл трассировку

du -sh ~ вес домашнего каталога

Списки

cmd ; cmd  безусловный список
cmd || cmd условный список ИЛИ
cmd && cmd  условный список И

cmd & cmd

Параллеьное выполнение
find / -size 0 2> /dev/null 1> /tmp &

#!/bin/sh диалект сценария

#!/bin/bash

# Comment

echo Hello! $1

// если список команд закончился успехом, то выполняем ветку
if test "$1" = "" 
then
    echo Hello!
else
    echo Hello! $1
fi


https://www.youtube.com/watch?v=WVHC5Ggl7k4 7мин