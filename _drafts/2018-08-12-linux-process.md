--- 
layout: post 
title: Linux.Процессы и потоки
permalink: linux-process
tags: linux

--- 
##Понятие процесса

### Внутреннее устройство процесса

![process](/assets/images/2018-08-12-linux-process/process1.png "process")

Под процессом понимают программу, которая находится в процессе выполнения

Программа - состоит из исполняемых файлов (Executable files) и библиотек (libraries), между ними существует зависимость

Одна программа может выполняться в нескольких процессах.

Процесс - это такой контейнер для всех ресурсов необходимых для работы программы или ее части в многозадачных операционных системах, некий черный ящик

Многозадачность - это поведение программ
Исполняемые файлы зависят от библиотек, библиотеки в свою очередь могут зависеть от других библиотек

виртуальная среда 0 - 2(32) 4 гб - максимально адресуемое адресное пространство
В реальности выделяется столько столько нужно
4 гб деляться на 2гб (Kernel, для обслуживания ядра) 2гб (Process)
 
Что в процесс попадает
1. Text(Code)(rx) -  программный код, то есть те инструкции которые были взяты
из исполняемый файлов для выплнения
2. Data (RWDATA)(rw) (RODATA) (r) - данные программ
3. Stack для огранизации процедурных вычислений (A-B-C-A) Очередность выполнения
4. Heap -  динамичекие данные операционной системы для чтения данных
порядок освобожения не определен, до тех пор пока пямять в 2гб для этого процесса не закончиться

Ресурс процесса закончиваеться когда заканчивается память процесса

### Как формируеться содержимое процесса

При запуске программы формируется процесс, и его содержание заполняються сегменты секции процесса.
Библиотке может попасть в сегменты процесса если явно связана с исполняемым файлом 
или при неявной загрузки в момент выполнения при выполнении программы


Когда мы запускам программы в консоли, тогда запускаються соответствующие программы из 
/bin (основные) или /sbin (прикладные) , они используют раздляемые библиотки

### Зависимости

Узнать от чего зависит программа `ldd /bin/ls`
Самая важная библиотка это библиотка языка C libc.so.6
Воображаемая библиотка linux-gate.so.1 как шлюз

Библиотка - это раздяляемый обьект - его нужно явно загрузить
Программа - это исполняемый обьект

Можно проверть от чего зависит программа или библиотки командой `ldd`

libwrap.so.0.7.6 , где 
0 - номер версии интерфейса то что реализуемо 
7 - номер версии реализации ()
6 - исправлении ошибок - говорит о том что 6 раз исправлялась 7-я реализация библиотки


### Файлы процесса

`top` `ps`

Каждый из процессов имеет свой обьем виртуальной памяти

Всю информацию о процессах эти команды черпают их каталога /proc
можно зайти туда и посмотреть информацию
Там можно посмотреть карту сегментов процесса, библиотки, программы, код программы куча, стек, окрытые файлы
В превдосистеме proc можно увидеть всю поднаготную процесса, просто нужно знать то искать

### Атрибуты процесса

Это его свойства, механизм управления заданиями

WD - Рабочий каталог - точка отсчета путевых имен
UMASK - Реверсивная маска доступа к процессу
Enviroment - Переменные окружения процесса (Var1, Var2)
PID - Идентификатор процесса - число, уникальный идентификатор
PPID - Идентификатор родительссого процесса
SID - Идентификатор сеанса, все процессы одного пользователя на одном терминале
TTY - Идентификатор терминала, управляющий процессом
PGID - Идентификатор группы процесса
TPGID - Тнрминальная группа процессов (foreground group) - особенная группа
NICE - Относительный приоретет ((Low)20  0 -19 (High)) любезность процесса
PRI - Абсолютный приоретет - Чем больше тем лучше
    Режим контроля доступа
RUID - Real UID Настоящий идентификатор пользователя именно этот пользователь запустил эту программу в этом процессе
EUID - Effective UID Действующий идентификатор, то от кого программа работает, кто бы ее не запустил
RGID - Real GID Группа
EGID - Effective GID

В большинстве случаем они равны (SUID)

Запросы команды ps можно формировать так как нам в реальности нужно

Программа запущенная в операционной системе будет всегда иметь процесс

Процессор переключается между процессами, предоставляя каждому процессу долю процессорного времени - это называется многозадачным режимом работы.
По сути процесс - это действия выполненные при чтении программы, у него есть входные, выходные данные и состояние. 
Программа может быть сохранена в виде текста, процесс может только выполняться. 
Есть возможность запустить два процесса от одной программы.

### Порождение процессов

PID1(parent) (fork()) COPY полностью процесс - PID2(child)

### Запуск программы

PID1 (exec()) LOAD Замещение новой программы в этом самом же процессе

### Запуск в новом процессе новой программы

PID1 (fork()) COPY PID2 (exec()) LOAD


### Завершение работы процесса

PID2(child) (exit()) SIGCHLD (код возврата) PID1(parent)
Родитель делает wait()
Zombie - процесс еще сузествует, но по факту его нет

## Создание  процесса

Новый процесс всегда создается за счет уже существующего процесса. Чтобы создать "процесс-потомок" родительский процесс 
выполняет системный вызов `fork()`, "процесс потомок" является копией родительского процесса. 
Далее новый процесс начинает жить "своей жизнью", например с помощью выполнения системного вызова `exec()`, загружает в пространство процесса
новую программу, при этом родитель и потомок обладают своим собственным адресным пространством.

## Завершение процесса

Процесс может быть завершен если он завершил свою работу либо при возникновении ошибок. Так же можно принудительно
завершить процесс командой `kill {pid процесса}`

## Состояния процесса

Здесь процесс может выполняться, ждать или быть заблокированным. Важно решить сколько процессорного времени какой процесс будет выполняться
за это отвечает **планировщик**. 

Планировщик - работает на самом низком уровне операционной системы, он занимается обработкой прерываний.
Планировщик использует **таблицу процессов**, в ней находятся все сведенья о состоянии процесса.

Некоторые характеристики процесса:
    
  1. Регистры
  1. Счётчик команд
  1. Слово состояния программы
  1. Указатель стека
  1. Состояние процесса
  1. Приоритет
  1. Параметры планирования
  1. Идентификатор процесса
  1. Родительский процесс
  1. Группа процесса
  1. Сигналы
  1. Время начала процесса
  1. Использованное процессорное время
  1. Процессорное время дочернего процесса
  1. Время следующего аварийного сигнала
  1. Указатель на текстовый сегмент
  1. Указатель на сегмент данных
  1. Указатель на сегмент стека
  1. Корневой каталог
  1. Рабочий каталог
  1. Дескриптор файла
  1. Идентификатор пользователя
  1. Идентификатор группы

Процесс может быть прерван множество раз, но после прерывания процесс возвращается к тому же состоянию в котором он был,
до прерывания.

## Потоки

У каждого процесса есть адресное пространство, при необходимости параллельных вычислений, выделяют **потоки**, которые
используют общую память.

Для примера можем взять процесс веб-сервера, он имеет поток диспетчера, несколько рабочих потоков. Где поток диспетчер - это
бесконечный цикл, для получения рабочего запроса, далее запрос передается рабочему потоку.


----

