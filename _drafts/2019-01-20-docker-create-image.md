--- 
layout: post 
title: Создание образа docker. part 1
permalink: docker-create-image
tags: docker linux
comments: true
---

Образ Docker - это файловая система в формате "read-only". Образ состоит из слоев которые накладываются друг на друга
Образ создается на основе `Dockerfile` и контекста. Контекст - это файлы находящийся в заданном месте например
в корне проекта.

Для создания образа используеться команда `docker build` с ключами:

~~~bash
--file, -f # путь до Dockerfile, по умолчению ./
--tag, -t # имя образа
--no-cache # запретить кеширование образов

~~~

И `Dockerfile`, в котором указаны инструкции для выполнения.

В качестве примера возмем образ [busybox](https://hub.docker.com/_/busybox), посмотрим из чего состоит его `Dockerfile`

~~~bash
FROM scratch
ADD busybox.tar.xz /
CMD ["sh"]
~~~

Первой инструкцией всегда должна идти инструкция `FROM`, в которой указывается базовый образ. Далее нужно создать файловую
систему образа, воспользуемся командой `ADD` которая рекурсивно скопирует файлы из контекста в создаваемый образ, в данном
случае будет распакован архив. Последняя команда `CMD` запустит указанную инструкцию во время создания контейнера.

Скачаем образ командой `docker pull busybox`, в данном случае можно обойтись и без сборки образа, так все что нужно уже
находиться в родительском образе, но мы соберем собственный образ укажем только одну команду `FROM busybox`

~~~bash
docker build -t test .
~~~

где укажем название и контекст ,текущая директория запуска этой команды

~~~bash
docker build -t test .
Sending build context to Docker daemon  3.072kB #1
Step 1/1 : FROM busybox #2
latest: Pulling from library/busybox #3 
b4a6e23922dd: Pull complete #4
Digest: sha256:8ccbac733d19c0dd4d70b4f0c1e12245b5fa3ad24758a11035ee505c629c0796 #4
Status: Downloaded newer image for busybox:latest #5
 ---> 758ec7f3a1ee #6
Successfully built 758ec7f3a1ee #7
Successfully tagged test:latest #8
~~~

Разберем вывод команды построчно

Я создал файл hello в качестве контекста. Первое что делает процесс сборки - это отправляет весь контекст в демон (#1).
В данном случаее это мой фаил hello. Далее начиначет читать инструкции из `Dockerfile` (#2). Проверяем если данного образа
нет на локальной машине то он будет скачан (#3 ,#4, #5, #6, #7). 
Так как мы создавали новый образ на основе busybox, но в `Dockerfile` была только одна команда, будет создан полностью
одинковый образ с родительским (#8).

Для проверки будем создавать новый контейнер на основе наших образов командой `docker run --name myconteiner -it --rm test`, 
запускать его, попадать в оболочку и по выходу койнейнер будет удален.

На что следует обратить внимание при создании образа:
1. Необходимо обязательно передавать контекст в команду `docker build`
2. Каждая инструкция в `Dockerfile` создает новый слой (уровень), который кэшируется и при успешном созданий может быть
переиспользован при пересборке образа
3. Не обязательно всегда создавать образ с нуля, можно воспользоваться уже готовыми образами поискав в [реестре образов](https://hub.docker.com/)
4. Для получения новой версии образа необходимо явно выполнять команду `docker pull`

### Dockerfile

До этого мы рассмотрели лишь некоторые инструкции из `Dockerfile`, рассмотрим другие инструкции, которые можно использовать:

1. `FROM` - определяет основной образ на основании которого будет создан текущий, эта инструкция должна быть первой в `Dockerfile`
   например `FROM ubuntu:latest`
2. `RUN` - команда выполняет любые консольные инструкции в текущем слое образа например `RUN apt-get update`, по умолчанию
    для linux это программа `/bin/sh -c`. Команда `RUN` имеет еще вторую форму записи exec, например `["/bin/bash", "-c", "apt-get update"]`.
    Еще один пример
    ~~~bash
    RUN ln -sf /dev/stdout /var/log/nginx/access.log \
    && ln -sf /dev/stderr /var/log/nginx/error.log
    ~~~
3. `CMD` - запускает инструкцию во время инициализации контейнера. Инструкция может быть использована только один раз и
    служит для передачи параметров для запуска контейнера. Данная команда ничего не выполняет во время сборки, а задает
    команду которая будет запущена во время запуска контейнера, пример `CMD ["nginx", "-g", "daemon off;"]` или `CMD ["php", "-S", "0.0.0.0:9095", "-t", "public", "public/index.php"]`
4. `ENTRYPOINT` - определяет фаил который будет запущен при инициализации контейнера, часто используеться огранизации скриптов
    запуска пример `ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]` или `ENTRYPOINT ["docker-entrypoint.sh"]`
5.  `LABEL` - добавляет метажанные к образу, например `LABEL maintainer="NGINX Docker Maintainers <docker-maint@nginx.com>"`    
6.  `EXPOSE` - указывает какие порты прослушивать докер контейнеру, например `EXPOSE 80`
7.  `ENV` - задает переменные окружения внутри образа, данные переменные доступны в последующих инструкциях, к примеру `ENV NGINX_VERSION 1.15.8-1~stretch`
8.  `ADD` - копирует файлы из контекста в образ, например `ADD busybox.tar.xz /tmp/` , поддержка указания url адреса 
     в качестве источника и так же автоматически умеет распаковывать архивы. Но нельзя автоматически скачать архив и распаковать его
9.  `COPY` - используеться для копирования файлов из контекста создания в образ, например `COPY config/ /etc/mysql/`
     Что же лучше использовать `ADD` или `COPY`. Лучше использовать `COPY` 
10. `VOLUME` - создает точку монтирования внутри образа`VOLUME /var/lib/mysql`. Простыми словами - это папка хоста примонтированная
к контейнеру
11.  `WORKDIR` - определяет рабочий каталог, для инструкций которые будут выполнены в dockerfile

### Ссылки

1. [union file system](https://ru.wikipedia.org/wiki/UnionFS) - UnionFS - файловая система для объединения слоев

Предыдущие статьи:
- [Идеология docker. part 0](http://lexusalex.ru/docker-ideology)






   


 



 