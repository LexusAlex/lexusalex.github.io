--- 
layout: post 
title: Работа с функциями в php
permalink: php-functions
tags: php
--- 

##Чистая функция

~~~php
<?php
// результат функции полностью зависит от входных параметров, что поддается контролю и упрощает тестирование
function test($a, $b, $c)
{
    return ($a + $b + $c);
}

// результатом функции является случайное число, его невозможно предугадать
function test1($a)
{
    return random_int(10,20) + $a;
}

// функция обращается к суперглобальному массиву $_SERVER. Значение ключа массива на другом сервере может быть другим
function test2()
{
    return $_SERVER['SERVER_SOFTWARE'];
}
?>
~~~

Функция `test()` является детерминированной, так как ведет себя предсказуемо, результат полностью зависит от входных параметров.
Напротив `test1()` и `test2()`, такой функцией не является, так как результат всегда разный, ее нельзя протестировать.

По возможности нужно писать детерминированные функции как `test()`

Посмотрим на примеры:

~~~php
<?php
// создаем и пишем в фаил
function test3()
{
    file_put_contents('file.txt', 'Текст для записи', FILE_APPEND);
}

// функция с побочным эффектом если выводит текст на печать
function test4()
{
    echo 'text';
}
?>
~~~

Функция с побочным эффектом - это функция которая обращаеться к глобальным переменным, пишет и читает из файла, работает
с базой данных.

Нужно уметь отделять побочные эффекты от чистого кода.

Типичная задача веб - приложения.
1. Принять пользовательский запрос
2. Отдать пользователю ответ

Между первым и вторым шагом происходит основная работа, а побочные эффекты можно вынести в начало и в конец работы приложения, то есть
изолировать и отделять чистый код от нечистого.

Если функция детерминированная и без побочных эффектов то он называется чистой, чего и нужно стремиться


~~~php
<?php
// функция занимается вставкой данных в базу данных
function test5()
{
    $mariadb = new PDO('mysql:dbname=root;host=mariadb;port=3306', 'root', 'root', [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES => false,
    ]);

    $stm = $mariadb->prepare('INSERT INTO test (text) VALUES (:text)');
    return $stm->execute([':text' => 'текст1']);
}
?>
~~~

Какие проблемы сразу видны в этой функции: 
-   Функция с побочными эффектами (обращение к базе данных)
-   Учетные данные храняться прямо в функции

Выделим код соединения с базой в отдельную функцию и создадим метод `insert`

~~~php
<?php

function connect($data)
{
    return new PDO("mysql:dbname=$data[dbname];host=$data[host];port=$data[port]", $data['login'], $data['pass'], [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES => false,
    ]);

}

function insert($pdo)
{
    $stm = $pdo->prepare('INSERT INTO test (text) VALUES (:text)');
    return $stm->execute([':text' => 'текст1']);
}
?>
~~~

Функция `insert` вернет `true` или `false` как результат выполнения операции вставки в базу. Повторное выполнение этой
функции приведет к повторной вставке данных


Структура пары









https://ru.hexlet.io/courses/php-object-oriented-design

Особенности функций в php. Просто что важно знать.

Функция - это особый объект который можно вызвать. 
Как правило функция - это действие.

Рассмотрим пример, мы объявили функцию `additionNumbers()` которая складывает два числа и возвращает результат.
Обратите внимание функцию можно вызвать *до* ее определения, но это плохая практика.
~~~php
echo additionNumbers(5, 8); // 13

/**
 * @param int $a
 * @param int $b
 * @return int
 */
function additionNumbers(int $a, int $b)
{
    return $a + $b;
}

echo additionNumbers(2, 3); // 5
~~~


Функция `additionNumbers()` является **детерминированной** то есть она всегда для одних и тех же входных параметров
возвращает один и тот же результат. Это важно, такие функции проще читать, отлаживать, тестировать. Так же порядок вызова
таких функции не важен.

Напротив недетерминированными являются функции например `rand()` возвращает случайное число, `date('Y')` возвращает текущий год, все эти значения меняются например, 

~~~php
echo rand(); // 808483848
echo rand(); // 940960349

echo date('Y'); // 2018 (скоро год поменяется)
~~~

Перепишем нашу функцию, и выведем полученное число

~~~php
/**
 * @param int $a
 * @param int $b
 * @return int
 */
function additionNumbers(int $a, int $b)
{
    echo $a + $b; // побочный эффект функции
    return $a + $b;
}

additionNumbers(2, 4); // 6
~~~

Теперь функция `additionNumbers()` имеет **побочный эффект**, а именно вывод числа во внешнюю среду выполнения.
То есть если функция обращается к глобальным переменным, или еще хуже меняет их, пишет данные в фаил, выполняет
операцию ввода/вывода, любое внешнее взаимодествие, это функция с побочным эффектом. Необходимо отделять чистый
код функции от побочных эффектов 

## Аргументы

Вычиление аргументов идет слева направо, сначала идут обязательные, а потом необязательные параметры, это убережет от многих проблем в будущем

~~~php
/**
 * Возвращает уникальные номера массива
 * @param array $numbers
 * @return array
 */
function getUniqueNumber(array $numbers = []) : array
{
   return array_unique($numbers, SORT_NUMERIC);
}

print_r(getUniqueNumber([3, 5, 4, 3, 2, 5, 3, 2, 5, 3])); // Array ( [0] => 3 [1] => 5 [2] => 4 [4] => 2 )
~~~

В функции `getUniqueNumber()` в качестве параметра передаем массив, для это используем уточнение типа аргумента.
К настоящему моменту типы которые могут быть заданы в аргументах:

1. Класс/Интерфейс `(SessionHandler $sessionHandler)` / `(Serializable $serializable)`
1. Массив `(array $array)`
1. Функция `(callable $function)`
1. Логический тип `(bool $bool)`
1. Число с плавающей точкой `(float $float)`
1. Число `(int $int)`
1. Строка `(string $string)`
1. Параметр либо массив, либо обьект класса Traversable `(iterable $iter)`
1. Объект `(object $o)`

Псевдонимы для ключевых слов не поддерживаются, так же можно обнулить объявление типа таким образом `(A $a = null)`

Теперь можно передавать в функцию неограниченное число аргументов

Splat оператор
~~~php
/**
 * Считает кол-во аргументов переданных в функцию
 * @param mixed ...$arguments
 * @return int
 */
function countArguments (...$arguments) : int
{
    return count($arguments);
}

var_dump(countArguments(1, 2, 9, [], 'str')); // 5
~~~

Как видим стало проще обрабатывать функции с переменным количеством аргументов. 
Также можно при вызове функии распаковать массив в аргументы (предполагается , что функция содержит 5 аргументов):

~~~php
countArguments(...[1, 2, 9, [], 'str']);
~~~

Уточнение типа с многоточием работает точно так же как и с обычными аргументами `(int ...$arguments)`, все элементы массива должны быть числами

В идеале, не допускать в функции больше трех аргументов. Не используйте флаги в качестве параметров функции

## Результат функции

Функция всегда должна возвращать значение, для этого используеться конструкция `return`, при этом если не указать эту конструкцию, то функция вернет `null`
Как и с типами аргументов, можно задать и тип возвращаемых значений (аналогично аргументам)

## Анонимные функции

Это функция без имени






Чистые функции обладают рядом ключевых достоинств:

    Их крайне просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
    Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
    Их легко комбинировать получая новое поведение без необходимости переписывать программу (подробнее далее по курсу).

являеться ли число простым

function isPrime(int $num)
{
    if ($num < 2) {
        return false;
    }

    for ($i = 2; $i < $n um / 2; $i++) {
        if ($num % $i == 0) {
            return false;
        }
    }

    return true;
}

function sayPrimeOrNot($num)
{
    $text = isPrime($num) ? 'yes' : 'no';
    print_r($text);
}


<?php

namespace App\Math;

// BEGIN (write your solution here)
function average(...$arg)
{
    if(empty($arg)) {
        return null;
    }

    return (array_sum($arg) / count($arg));
}
// END
команда

Всегда связана с выплнением побочных эффектов

запрос

Не меняет состояние системы



array_map отображение
array_filter фильтрация элементов массива
array_reduce  агрегация

Нужно выделать опрации отображения, фильтрации и агрегации в отдельные сущности

Функция не должна делать много
Функция может выбрасывать ислючения?
Самое главное это правильная абстракция, принятие ключевых решений нужно откладывать до конца. Слишком рано превращаеться
в слишком поздно

Нужно строить обработку так, чтобы те состояния от которых можно избавиться как можно раньше, мы избавляемся как можно раньше

Кореляция и причинно-следственная связь

Семантическое нарушение, если код рождает тож же самый результат, но не предназначен для этого. Если нет работы 
со стеком то не стоит создавать там это

Отделять побочный эффект от кода функции

Нужно стремится к этому
Побочный эфект
Чистый код
Побочный эфект

Вводить явно выделенные состояния

**Именование**

В php в качестве имени функции можно использовать символы `A-Za-z0-9_`.
При реализации функции мы должны описать действие которое делает функция, для этого используем глагол (напиши, положи и тд.)

~~~php
showDate() // показать дату
removeDate() // удалить дату
print() // вывести
getTableSchema() // вернуть схему таблицы
symbolsCount() // количество символов
~~~

Если функция возвращает логическое значение то используется приставка `is`

~~~php
is_array() // это массив?
is_null() // это null?
isTransactional() // это транзакция?
~~~

Есть внегласные правила в именовании:

~~~php
setProperties() // установить свойства
getId() // вернуть id
hasPath() // проверить путь
hasChild() // проверить на дочерний элемент
canView// кто может просматривать
~~~

давай-те функциям понятные названия



Вот, теперь мы подобрались к сути. Вы исходите из ошибочного предположения что обучение на хекслете это только последовательность уроков. Но на самом деле, главная фишка проекта это менторская поддержка (то чем я сейчас и занимаюсь). Вспомните школу или институт. Если бы можно было учиться только за счет грамотно простроенного контента, то преподаватели стали бы просто не нужны. Но мир так сложен, что невозможно научить без поддержки со стороны живого человека. Например для того чтобы вы смогли написать хорошо даже примитивную программу (скажем строк на 10), мне нужно вас обучить такому количеству вещей, что вы бы сказали "пойду найду другую школу, тут какие-то теоретики и за месяц я даже не дошел до того чтобы начать писать код". Поэтому любое обучение всегда идет с пропусками, которые нагоняются в процессе и не последнюю роль играет в этом ментор (и в целом та база знаний которая появляется в вопросах ответах). И даже при такой структуре, нет никакой физической возможности обучить вас всем хорошим практикам. После любого института человек на производстве доучивается и переучивается месяцами, а то и годами.

Так что по сути мой ответ был как раз тем самым живым обучением, которым вы бы могли воспользоваться и, например, задать уточняющие вопросы или попросить пояснить. Примерно такую реакцию ожидает преподаватель от заинтересованных учеников. В том как это работает вы можете легко убедиться почитав другие топики, где разворачиваются большие и интересные дискуссии.

p.s. я не дружу с запятыми, так что не серчайте)



Рассмотрим, что себя представляют функции в php

---
## Что мы знаем о функциях в php

1. Функции обычно определяют заранее, но это не обязательно, интерпретатор сначала определит все функции в файле, а потом начнет исполнение скрипта
    ~~~php
    <?php
        echo test(); // будет выведено 'test' несмотря на то что декларация функции идет ниже
    
        function test() {
            return 'test';
        }
    ?>
    ~~~
1. Функции можно вкладывать друг в друга, но вложенные функции можно вызвать только в том случае если вызваны родительские функции
    ~~~php
    <?php
        //если вызвать test2() без вызовать test() то получим ошибку Call to undefined function test2()
        test();
        test2();
        echo test3(); // будет выведено 'function test 3'
    
        function test() {
            function test2() {
                function test3() {
                    return 'function test 3';
                }
            }
        }
    ?>
    ~~~
1. Все функции имеют глобальную область видимости, могут быть вызваны в любом месте (к вопросу о рекурсии)
1. Не поддеживается переопределение и удаление функции
    ~~~php
    <?php
        function test() {
            return 'test';
        }
    
        function test() { // при такой декларации получим ошибку что такая функция уже есть Cannot redeclare test() (previously declared in
            return 'test2';
        }
    
    ?>
    ~~~
1. Переполнение стека рекурсии является программной ошибкой
1. Передача аргументов в функцию по значению, это значит что значения аргументов изолированы внутри функции. В качестве примера посмотрим на вызов функции
    ~~~php
    <?php
        function text($string) {
            $string .= ' (last text)';
        }
        $str = '(first text)';
        text($str);
        $str .= ' (some text)';
        text($str);
        echo $str; //(first text) (some text) 
    ?>
    ~~~
    Не смотря на то, что функция была вызвана 2 раза, внутренняя переменная `$string` не фигурирует в ответе
    
    TODO ---
    

## Детерминированность функции
  
Функция называется детерминированной если она всегда для одних и тех же наборов входных данных возвращает один и тот же результат

Как пример функции `rand();` и `date('Y');` называют не детерминированными, так как rand всегда возвращает случайное число, а
date, возвратит текущий год, а он тоже меняется.

Детерминированные функции, напротив, ведут себя предсказуемо. Для одних и тех же входных данных, они всегда выдают один и тот же результат.
Это важно так как это дает предсказуемость возвращаемых значений функции, и количество состояний которые нужно обрабатывать.

Понятие детерминированность важно в тех вопросах где важно состояние, например задачи связанные с настройкой серверов должна быть детерминированной
Так же функция становиться не детерминированной если она обращается к внешним данным, глобальными переменным, потому что в процессе работы программы они могут изменится, и соответственно изменится вывод функции

По возможности создавайте такие функции которые зависят только от своих аргументов.

## Побочный эффект функции

Побочным эффектом называют любые действия которые изменяют среду выполнения такие как изменение файла, отправка и прием данных по сети, обращение к глобальным переменным
Наличие побочных эффектов приводит сложносям при разработке, трудности в тестировании и отладке.

Такие операторы как инкремент и декремент являютсяч операторами с побочными эффектами, они согут приводить к сложноотловимым ошибкам


Их крайне просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
Их легко комбинировать получая новое поведение без необходимости переписывать программу.

В программах побочные эффекты нужно изолировать что основная часть кода была чистой

Здесь необходимо отделять чистый код в функции
  
  
  
    Детерминированность
    Побочные эффекты
    Splat operator
    Объекты первого рода
    Функции высшего порядка (map/filter/reduce)
    Функциональное программирование

