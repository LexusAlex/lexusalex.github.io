--- 
layout: post 
title: Про Git
permalink: linux-git
tags: git github
--- 
![git](/assets/git/git.jpg)

Так уж вышло , что система котроля версий git стала стандартом и используется повсеместно при разработке 
и для хранения исходного кода
Git работает во всех операционных системах, на оф. сайте подробно описаны способы установки например,
[установка git в правильной операционной системе](https://git-scm.com/download/linux)


---
## Содержание
- [Установка](#установка)
- [Настройка](#настройка)
- [Список настроек](#список-настроек)
- [Директория .git](#директория-репозитория-(.git))
- [Хранение объектов](#хранение-объектов)
- [Команды git](#команды-git)

- [init](#init)
- [clone](#clone)
- [Состояния файлов](#состояния-файлов)  
- [Текущее состояние репозитория](#текущее-состояние-репозитория)  
- [status](#status)


## Установка

Здесь все просто, для linux git можно поставить стандартным способом

~~~bash
apt-get install git
~~~

Обновиться до последней версии можно так
~~~bash
sudo add-apt-repository ppa:git-core/ppa
sudo apt update
sudo apt install git
~~~

Проверим версию (последняя на данный момент версия 2.19.0 от 10.09.2018)

~~~bash
git --version

git version 2.19.0

~~~

Все ок. Для Windows и MacOS просто скачивается инсталятор.

## Настройка

Перед использованием git его нужно настроить, для этого существуют переменные конфигурации, они лежат
в разных местах файловой системы.

- локальные (local)(default) - на уровне конкретного репозитория
- пользователельские (global) - для всех репозиториев пользователя
- системные (system) - для всех пользователей системы

**Локальные настройки**

Они хранятся в файле `.git/config` и действуют только на конкретный репозиторий

**Пользовательские настройки**

Они находятся в файле `~/.gitconfig` и распространяются на все репозитории данного пользователя, здесь находяться
большинство настроек

**Системные настройки**

Располагаются в файле `/etc/gitconfig` и действуют на всех пользователей системы


Настройки каждого следующего уровня перекрывают настройки предыдущего.

Для управления настройками существует утилита `git config`. 
Нужно обязательно указать email и имя пользователя,
так как эта информация будет использоваться в коммитах

~~~bash
git config --global user.name "alex"
git config --global user.email "alexsey_89@bk.ru"
~~~

В данном случае мы указали ключ `-- global` тем самым установили настройки для всех репозиториев конкретного пользователя.

Посмотреть настройки для всех трех уровней и все настройки можно командами:

~~~bash
git config --system -l
git config --global -l
git config --local -l
git config -l
~~~
Установим редактор по умолчанию для всех внешних файлов

~~~bash
git config --global core.editor vim
~~~

Все параметры git хранит в файлах в тектовом виде, можно их изменять напрямую, но правильнее воспользоваться командой
`git config` , для добавления, изменения, удаления настроек на нужоном уровне.

~~~bash
git config 
использование: git config [<опции>]

Размещение файла конфигурации
    --global              использовать глобальный файл конфигурации
    --system              использовать системный файл конфигурации
    --local               использовать файл конфигурации репозитория
    -f, --file <файл>     использовать указанный файл конфигурации
    --blob <идент-двоичн-объекта>
                          прочитать настройки из указанного двоичного объекта

Действие
    --get                 получить значение: имя [шаблон-значений]
    --get-all             получить все значения: ключ [шаблон-значений]
    --get-regexp          получить значения по шаблону: шаблон-имен [шаблон-значений]
    --get-urlmatch        получить значение, специфичное для URL: раздел[.переменная] URL
    --replace-all         заменить все соответствующие переменные: имя значение [шаблон-значений]
    --add                 добавить новую переменную: имя значение
    --unset               удалить переменную: имя [шаблон-значений]
    --unset-all           удалить все совпадающие: имя [шаблон-значений]
    --rename-section      переименовать раздел: старое-имя новое-имя
    --remove-section      удалить раздел: имя
    -l, --list            показать весь список
    -e, --edit            открыть в редакторе
    --get-color           найти настроенный цвет: раздел [по-умолчанию]
    --get-colorbool       проверить, существует ли настроенный цвет: раздел [stdout-есть-tty]

Тип
    --bool                значение — это «true» (правда) или «false» (ложь)
    --int                 значение — это десятичное число
    --bool-or-int         значение — это --bool или --int
    --path                значение — это путь (к файлу или каталогу)
    --expiry-date         значение - это дата окончания срока действия

Другое
    -z, --null            завершать значения НУЛЕВЫМ байтом
    --name-only           показывать только имена переменных
    --includes            учитывать директивы include (включения файлов) при запросе
    --show-origin         показать источник настройки (файл, стандартный ввод, двоичный объект, командная строка)

~~~


## Список настроек

Настроек достаточно большое количесво, перечислю лишь некоторые из них.
Они все разбиты на секции. 
Все возможные команды можно посмотреть в [официальной документации](https://git-scm.com/docs/git-config)

- user
    - name - имя пользотваеля для коммитов
    - email - email пользователя для указания в коммитах
- core
    - editor - редактор по умолчанию для внешних файлов
    - pager - задает способ вывода постраничной информации, по умолчанию используется программа less
    - autocrlf - автопреобазование окончания строк в файлах CRLF(\r\n)(windows)(2 байта) в LF(\n) (unix)(1 байт) и наоборот  
- color
    - ui - разрешать ли подсвечивать названия файлов в консили
- commit
    - template - сообщение для коммита по умолчанию, например для приведения коммитов к общему виду
    
## Директория репозитория (.git)

При создании репозитория, создается директория .git, в ней хранится история, за ней находятся рабочие файлы.
Удаление этой папки равносильно удалению репозитория, но удалив рабочие файлы, можно с легкостью их восстановить,
потому что git помнит все.

Можно просто скопировать эту папку на другой компьютер и восстановить все содержимое репозитория.
Посмотрим что там внутри
~~~bash
ls -1 .git
branches
COMMIT_EDITMSG
config # конфигурационные параметры проекта
description # используется программой GIT Web
FETCH_HEAD
HEAD # в какой ветке мы сейчас находимся
hooks # хуки
index # информация о области индексирования
info # глобальный фаил исплючений для репозитория
logs
objects # содержимое базы данных репозитория
ORIG_HEAD
refs # указатели на объеккты коммиты (ветки)

~~~

## Хранение объектов

Git храннит данные по принцыпу "Ключ - значение"

Файлы хранятся в таком виде, это хеш SHA-1, первые 2 символа это подпапка, имя файла остальные 38 символов

~~~bash
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
~~~

В эту папку можно с легкостью хранить и извлекать содержимое

более подробно об этом написано в [книге](https://git-scm.com/book/ru/v2/Git-%D0%B8%D0%B7%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-Git)

Есть такой тип объектов как дерево, вся информация храниться в виде обьектов-диревьев и blob-объектов.

Например посмотрим дерево последнего коммита

~~~bash
git cat-file -p master^{tree}

00644  blob 9de5bb6edf3220780cb2083da1449eabbff90e14    .editorconfig
100644 blob 7af431dc48c38b4d0773922c00bab6cb11d74039    .gitignore
100644 blob 9703ba819b75698f1260c1c97b3c81356f38cb96    404.html
100644 blob c344d146f49f6ebb8fb06709f403d1ada1f1e684    LICENSE.md
100644 blob 2b80ce1f7422ff0f7fa43b0d1b241b3ce6e2a2ce    README.md
100644 blob fcff6b4fc8ccce859e72f43e5286859be59c2a80    _config.yml
040000 tree 5ae4649736bfda9f7490d0a6238aeb301391a1d7    _drafts
040000 tree 281508b89836afef9ba9353f59958fb90dab03c5    _includes
040000 tree f66a9fa478e018920ab11d49b38163bf8dcfdf26    _layouts
040000 tree de290c9287546527a08a5bfae61195066137c1c7    _posts
100644 blob dc0546a28c37841d24f703477135b386a9f585ff    about.md
100644 blob 3679736bde970a7e7101320c844b67d100ec6477    archive.md
100644 blob 229c82d3e14512466c24fcfe3dc914c6ad7577da    atom.xml
100644 blob e57deda204c376e0e7d2b28ef53394d758803937    doc.txt
100644 blob f65a9a6b9cd7f2446a060ff5a8bab97b22243e65    index.html
040000 tree 52a6081748ccbfa21fc0b5ed7cf42ce85a185422    public
100644 blob 420da721e761631f73e29d73619bd619c6ca8332    tags.html
100644 blob 57f8fb8c2b93d36e9ebef7588d5447c44359e5b4    yandex_8c443a299bcfffc6.html
~~~

Здесь видно что blob - это фаил , tree - это директория, заглянем в директорию _posts

~~~bash
git cat-file -p de290c9287546527a08a5bfae61195066137c1c7
100644 blob 09335ffc3b61d5eec5bd6d1642772039195e96e2    2018-05-23-php-libraries.md
~~~

получим дочерние объекты, таким же образом харнятся объекты коммиты с версиями файлов, опять же сслыка на [книгу](https://git-scm.com/book/ru/v2/Git-%D0%B8%D0%B7%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-Git),
там все подробно описано

В итоге что мы имеем: 

Три типа объектов, массивы двоичных данных, дерево, коммит. 
Каждый из объектов имеет уникальный хеш
Коммит имеет ссылку на родительский коммит

![git](/assets/git/git-tree.png)

## Команды git

Git несколько часто используемых команд, набор низкоуровневых команд типа `git cat-file`

Посмотрим список всех доступных команд и псевдокоманд, прежде чем начинать использовать git

~~~bash
git help -a

  add                       checkout-index            diff-files                grep                      mailsplit                 notes                     remote-fd                 shell                     update-index
  add--interactive          cherry                    diff-index                hash-object               merge                     pack-objects              remote-ftp                shortlog                  update-ref
  am                        cherry-pick               diff-tree                 help                      merge-base                pack-redundant            remote-ftps               show                      update-server-info
  annotate                  clean                     difftool                  http-backend              merge-file                pack-refs                 remote-http               show-branch               upload-archive
  apply                     clone                     difftool--helper          http-fetch                merge-index               patch-id                  remote-https              show-index                upload-pack
  archive                   column                    fast-export               http-push                 merge-octopus             prune                     remote-testsvn            show-ref                  var
  bisect                    commit                    fast-import               imap-send                 merge-one-file            prune-packed              repack                    stage                     verify-commit
  bisect--helper            commit-tree               fetch                     index-pack                merge-ours                pull                      replace                   stash                     verify-pack
  blame                     config                    fetch-pack                init                      merge-recursive           push                      request-pull              status                    verify-tag
  branch                    count-objects             filter-branch             init-db                   merge-resolve             quiltimport               rerere                    stripspace                web--browse
  bundle                    credential                fmt-merge-msg             instaweb                  merge-subtree             read-tree                 reset                     submodule                 whatchanged
  cat-file                  credential-cache          for-each-ref              interpret-trailers        merge-tree                rebase                    rev-list                  submodule--helper         worktree
  check-attr                credential-cache--daemon  format-patch              log                       mergetool                 rebase--helper            rev-parse                 subtree                   write-tree
  check-ignore              credential-store          fsck                      ls-files                  mktag                     receive-pack              revert                    symbolic-ref
  check-mailmap             daemon                    fsck-objects              ls-remote                 mktree                    reflog                    rm                        tag
  check-ref-format          describe                  gc                        ls-tree                   mv                        remote                    send-pack                 unpack-file
  checkout                  diff                      get-tar-commit-id         mailinfo                  name-rev                  remote-ext                sh-i18n--envsubst         unpack-objects
~~~

из них часто используемые следующие:

~~~bash
git

Стандартные команды Git используемые в различных ситуациях:

создание рабочей области (смотрите также: git help tutorial)
   clone      Клонирование репозитория в новый каталог
   init       Создание пустого репозитория Git или переинициализация существующего

работа с текущими изменениями (смотрите также: git help everyday)
   add        Добавление содержимого файла в индекс
   mv         Перемещение или переименование файла, каталога или символьной ссылки
   reset      Сброс текущего состояния HEAD на указанное состояние
   rm         Удаление файлов из рабочего каталога и индекса

просмотр истории и текущего состояния (смотрите также: git help revisions)
   bisect     Выполнить двоичный поиск изменения, которое вносит ошибку
   grep       Вывод строк, соответствующих шаблону
   log        Вывод истории коммитов
   show       Вывод различных типов объектов
   status     Вывод состояния рабочего каталога

выращивание, отметка и настройка вашей общей истории
   branch     Вывод списка веток,  их создание или удаление
   checkout   Переключение веток или восстановление файлов в рабочем каталоге
   commit     Запись изменений в репозиторий
   diff       Вывод разницы между коммитами, коммитом и рабочим каталогом и т.д.
   merge      Объединение одной или нескольких историй разработки вместе
   rebase     Повторно применить коммиты над верхушкой другой ветки
   tag        Создание метки, вывод списка, удаление или проверка метки, подписанной с помощью GPG

совместная работа (смотрите также: git help workflows)
   fetch      Загрузка объектов и ссылок из другого репозитория
   pull       Извлечение изменений и объединение с другим репозиторием или локальной веткой
   push       Обновление внешних ссылок и связанных объектов

~~~
В дальнейшем будем рассматривать эти команды подробнее

## Создание рабочей области

Репозиторий можно создать путем копирования существующего или создания нового

### Инициализация репозитория

#### init

Создать новый репозиторий можно в пустом каталоге, либо в каталоге с уже созданным проектом, 
но не находящимся под контролем версий. После создания пустого репозитория будет создана уже знакомая нам директория
`.git`

~~~bash
git init test
Инициализирован пустой репозиторий Git в /home/alex/Рабочий стол/test/.git/
~~~

### Клонирование репозитория

Удаленный репозиторий содержит только директорию `.git`, хранить рабочую копию на диске просто незачем

#### clone
Также можно присоединится к разработке склонировав репозиторий, к примеру склонируем свой удаленный репозиторий размещенный на github

~~~bash
git clone https://github.com/LexusAlex/scratch.git test2
Клонирование в «test2»…
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 7 (delta 0), reused 7 (delta 0), pack-reused 0
Распаковка объектов: 100% (7/7), готово.
~~~
или так

~~~bash
git clone git@github.com:LexusAlex/scratch.git test2
~~~

Еще в рамках обучения можно склонировать локальный репозиторий

~~~bash
git clone test test-cloneКлонирование в «test-clone»… 
warning: Похоже, что вы клонировали пустой репозиторий.
~~~

### Состояния файлов

Перед тем как идти дальше нужно рассмотреть какие состояние файлов есть в git.

Git по сути хранит снимок всех файлов в конкретный момент времени. Все операции выполняются локально, так как хранятся
на диске это важно и отличает git от подобных систем.

У любых файлов находящихся под контролем версий есть состояние.
В git есть три основных состояния файла:
- Отслежиеваемые (tracked)
    - Индексированные (staged) -перевести файл в состояние staged, то есть подготовить их к коммиту
    - Модифицированные (modified) -это любой модифициронный файл после unmodified
    - Зафиксированные (unmodified) -фаил переходит в это состояние после коммита
- Не отслеживаемые (untracked)


Как выглядит рабочий процесс :
1. Создание/редактирование файла
2. Добавить в область индексирование (staged)
3. Зафиксировать изменения (unmodified)

Тут главное помнить гит помнит все, и можно вернутся в любое состояние проекта

### Текущее состояние репозитория

После создания репозитория логично посмотреть на его состояние для этого существует команда `git status`

#### status

В данном случаее команда ничего особенного не покажет, так как у нас нет еще файлов.
Команда показывает на какой ветке мы сейчас находимся и подсказки, давайте ими и воспользуемся

~~~bash
git status

На ветке master

Еще нет коммитов

нечего коммитить (создайте/скопируйте файлы, затем запустите «git add», чтобы отслеживать их)
~~~

Создадим фаил `test.php` , посмотрим вывод команды

~~~bash
 git status
 
На ветке master

Еще нет коммитов

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)

	test.php

ничего не добавлено в коммит, но есть неотслеживаемые файлы (используйте «git add», чтобы отслеживать их)

~~~

Получили первое состояние файла как Неотслежиеваемый, допустим нас устраивает этот файл мы ходим его добавить в область индексирования
командой `git add`

~~~bash

git add test.php 
git status

На ветке master

Еще нет коммитов

Изменения, которые будут включены в коммит:
  (используйте «git rm --cached <файл>…», чтобы убрать из индекса)

	новый файл:    test.php

~~~

Теперь фаил отслежиевается и добавлен в индекс для фиксации, как видим это новый фаил, а теперь смотрите изменим файл test.php

~~~bash
git status
На ветке master

Еще нет коммитов

Изменения, которые будут включены в коммит:
  (используйте «git rm --cached <файл>…», чтобы убрать из индекса)

	новый файл:    test.php

Изменения, которые не в индексе для коммита:
  (используйте «git add <файл>…», чтобы добавить файл в индекс)
  (используйте «git checkout -- <файл>…», чтобы отменить изменения
   в рабочем каталоге)

	изменено:      test.php

~~~

фаил находится сразу в двух состояниях, подготовленном для коммита и зафиксированном, теперь снова добавим в индекс и зафиксируем изменения

Сделаем первый коммит
~~~bash
git commit -m "first commit"
[master (корневой коммит) f0bb85e] first commit
 1 file changed, 3 insertions(+)
 create mode 100644 test.php
~~~

~~~bash
git status
На ветке master
нечего коммитить, нет изменений в рабочем каталоге
~~~

а теперь удалим файл

~~~bash
git status
На ветке master
Изменения, которые не в индексе для коммита:
  (используйте «git add/rm <файл>…», чтобы добавить или удалить файл из индекса)
  (используйте «git checkout -- <файл>…», чтобы отменить изменения
   в рабочем каталоге)

	удалено:       test.php

нет изменений добавленных для коммита
(используйте «git add» и/или «git commit -a»)
~~~

Думаю понятна вся полезность этой команды, но идем дальше, в дальнейшем мы ее будем всегда использовать, смотреть на состояние нашего репозитрия.
Выше мы использовали команду `git add` но о ней ниже

### Работа с текущими изменениями

#### add

Эта команда добавляет файты в индекс

Варианты ее использования
~~~bash
git add . # добавляет файлы в индекс в текущем каталоге
git add my.php # добавим фаил
git add my.php test.php # добавим несколько файлов
git add my test # добавим несколько директорий
~~~

https://ru.stackoverflow.com/questions/431839/%d0%92-%d1%87%d0%b5%d0%bc-%d1%80%d0%b0%d0%b7%d0%bd%d0%b8%d1%86%d0%b0-%d0%bc%d0%b5%d0%b6%d0%b4%d1%83-git-add-add-a-add-u-%d0%b8-add






http://alexprivalov.org/visual-git-guide

https://habr.com/company/ruvds/blog/359216/











### Просмотр состояния репозитория


Сейчас гит никак не отслеживает изменения этих файлов, как пишут в подсказке, нужно добавить файлы в отслеживаемые

### Добавление/Удаление файлов из отслеживаемых

Команда `git add` добавляет фаил или папку в отслеживаемые гитом

~~~bash
git add .gitignore

На ветке master
Еще нет коммитов

Изменения, которые будут включены в коммит:
  (используйте «git rm --cached <файл>…», чтобы убрать из индекса)

	новый файл:    .gitignore

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)

	README.md

~~~

Примеры

~~~bash
git add .gitignore text.txt # добавить существующие файлы или папки
git add . # добавить в отслеживаемые все файлы в папках и подпапках
git add -i # интераткивное добавление файлов
git add -p # поочередный просмотр файлов
~~~

Как правило git add с указанием папок или файлов хватает за глаза, об остальных ключах можно прочитать в доументации

Обратная операция, убрать из отслеживания команда ``git rm``

Примеры

~~~bash

git rm --cached readme.txt text.txt # удалить файл из отслеживаемых
git rm --cached -r folder # удалить папку из отслеживаемых

~~~

### Состояния файлов

- untracked - Не отслеживаемый фаил
- tracked - Отслежиеваемые фаилы, у этих файлов есть подтипы
    + unmodified - это не измененный файл в рабочей директории и в репозитории
    + modified - это измененный unmodified файл
    + staged - это файлы готовые к коммиту, то что делает команда git add
    
Давай-те к примерам. С неотслежиеваемыми файлами все понятно, на них гит никак не реагирует, они отображатся так

~~~bash

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)

	README.md

~~~

Те файлы которые отслеживает гит, unmodified, их никак не отображает команда git status, это файл с которым мы ничего не делали в рабочей директории, но который закомичен.
Я уже сделал первый коммит, закомитив фаил .gitignore

~~~bash
git commit -m "add gitignore"
[master (корневой коммит) 4c0dc45] add gitignore
 1 file changed, 7 insertions(+)
 create mode 100644 .gitignore
~~~

В даном случае unmodified фаил это .gitignore, теперь изменим этот фаил, получим состояние modified, то есть измененный

~~~bash
На ветке master
Изменения, которые не в индексе для коммита:
  (используйте «git add <файл>…», чтобы добавить файл в индекс)
  (используйте «git checkout -- <файл>…», чтобы отменить изменения
   в рабочем каталоге)

	изменено:      .gitignore

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)

	README.md

~~~

Снова как написано в подсказке, добавим фаил, то есть подготовим фаил к коммиту, получим состояние staged, теперь эти изменения можно комитить.
Далее изменим снова фаил

~~~bash
git add .gitignore

vim .gitignore 

git status

На ветке master
Изменения, которые будут включены в коммит:
  (используйте «git reset HEAD <файл>…», чтобы убрать из индекса)

	изменено:      .gitignore

Изменения, которые не в индексе для коммита:
  (используйте «git add <файл>…», чтобы добавить файл в индекс)
  (используйте «git checkout -- <файл>…», чтобы отменить изменения
   в рабочем каталоге)

	изменено:      .gitignore

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)

	README.md

~~~

Видим что файл сейчас находится в двух состояниях staged и modified, если прямо сейчас сделать git commit, то изменения которые в индексе будут включены в коммит

### Удаление файлов из индекса

Команда ``git reset`` переводит фаил в состояние modified, то есть убираем его из подготовленных к коммиту, допустим в нашем случае, мы забыли что-то добавить в фаил .gitignore

~~~bash
git reset .gitignore
Непроиндексированные изменения после сброса:
M	.gitignore

~~~

В данном случае в файле останутся изменения которые были в двух состояниях

### Вернуть фаил в состояние репозитория

Команда ``git checkout`` совершает сброс к последнему закомиченному варианту файла, то есть удаляет все ваши изменения из рабочей копии

~~~bash
git checkout .gitignore
~~~

Так же этой командой можно бегать по истории коммитов, указав его хеш

~~~bash
git checkout b9533bb
~~~


 
### Ветки

